{"ast":null,"code":"/* eslint-disable func-names */export default function(){var _this=this;// Parts copied from https://github.com/chris-rudmin/Recorderjs\nvar BYTES_PER_SAMPLE=2;var CHANNELS=1;// 1=mono , 2=Stereo\nvar recorded=[];function encode(buffer){var length=buffer.length;var data=new Uint8Array(length*BYTES_PER_SAMPLE*CHANNELS);for(var i=0;i<length;i+=1){var index=i*BYTES_PER_SAMPLE*CHANNELS;var sample=buffer[i];if(sample>1){sample=1;}else if(sample<-1){sample=-1;}sample*=32768;data[index]=sample;// eslint-disable-next-line no-bitwise\ndata[index+1]=sample>>8;}recorded.push(data);}function dump(sampleRate){var bufferLength=recorded.length?recorded[0].length:0;var length=recorded.length*bufferLength;var wav=new Uint8Array(44+length);var view=new DataView(wav.buffer);// RIFF identifier 'RIFF'\nview.setUint32(0,1380533830,false);// file length minus RIFF identifier length and file description length\nview.setUint32(4,36+length,true);// RIFF type 'WAVE'\nview.setUint32(8,1463899717,false);// format chunk identifier 'fmt '\nview.setUint32(12,1718449184,false);// format chunk length\nview.setUint32(16,16,true);// sample format (raw)\nview.setUint16(20,1,true);// channel count\nview.setUint16(22,CHANNELS,true);// sample rate\nview.setUint32(24,sampleRate,true);// 44100 Khz\n// byte rate (channels * sample rate * block align)\nview.setUint32(28,CHANNELS*sampleRate*BYTES_PER_SAMPLE,true);// kbps = 1411\n// block align (channel count * bytes per sample)\nview.setUint16(32,CHANNELS*BYTES_PER_SAMPLE,true);// bits per sample\nview.setUint16(34,8*BYTES_PER_SAMPLE,true);// 16\n// data chunk identifier 'data'\nview.setUint32(36,1684108385,false);// data chunk length\nview.setUint32(40,length,true);for(var i=0;i<recorded.length;i+=1){wav.set(recorded[i],i*bufferLength+44);}recorded=[];var msg=[wav.buffer];postMessage(msg,[msg[0]]);}this.onmessage=function(e){if(e.data[0]==='encode'){encode(e.data[1]);}else if(e.data[0]==='dump'){dump(e.data[1]);}else if(e.data[0]==='close'){_this.close();}};}","map":{"version":3,"sources":["/home/amil/virufy-demo.github.io/src/helper/audio/encoder-wav-worker.js"],"names":["BYTES_PER_SAMPLE","CHANNELS","recorded","encode","buffer","length","data","Uint8Array","i","index","sample","push","dump","sampleRate","bufferLength","wav","view","DataView","setUint32","setUint16","set","msg","postMessage","onmessage","e","close"],"mappings":"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","sourcesContent":["/* eslint-disable func-names */\nexport default function () {\n  // Parts copied from https://github.com/chris-rudmin/Recorderjs\n  const BYTES_PER_SAMPLE = 2;\n  const CHANNELS = 1; // 1=mono , 2=Stereo\n  let recorded = [];\n\n  function encode(buffer) {\n    const { length } = buffer;\n    const data = new Uint8Array(length * BYTES_PER_SAMPLE * CHANNELS);\n    for (let i = 0; i < length; i += 1) {\n      const index = i * BYTES_PER_SAMPLE * CHANNELS;\n      let sample = buffer[i];\n      if (sample > 1) {\n        sample = 1;\n      } else if (sample < -1) {\n        sample = -1;\n      }\n      sample *= 32768;\n      data[index] = sample;\n      // eslint-disable-next-line no-bitwise\n      data[index + 1] = sample >> 8;\n    }\n    recorded.push(data);\n  }\n\n  function dump(sampleRate) {\n    const bufferLength = recorded.length ? recorded[0].length : 0;\n    const length = recorded.length * bufferLength;\n    const wav = new Uint8Array(44 + length);\n\n    const view = new DataView(wav.buffer);\n\n    // RIFF identifier 'RIFF'\n    view.setUint32(0, 1380533830, false);\n    // file length minus RIFF identifier length and file description length\n    view.setUint32(4, 36 + length, true);\n    // RIFF type 'WAVE'\n    view.setUint32(8, 1463899717, false);\n    // format chunk identifier 'fmt '\n    view.setUint32(12, 1718449184, false);\n    // format chunk length\n    view.setUint32(16, 16, true);\n    // sample format (raw)\n    view.setUint16(20, 1, true);\n    // channel count\n    view.setUint16(22, CHANNELS, true);\n    // sample rate\n    view.setUint32(24, sampleRate, true); // 44100 Khz\n    // byte rate (channels * sample rate * block align)\n    view.setUint32(28, CHANNELS * sampleRate * BYTES_PER_SAMPLE, true); // kbps = 1411\n    // block align (channel count * bytes per sample)\n    view.setUint16(32, CHANNELS * BYTES_PER_SAMPLE, true);\n    // bits per sample\n    view.setUint16(34, 8 * BYTES_PER_SAMPLE, true); // 16\n    // data chunk identifier 'data'\n    view.setUint32(36, 1684108385, false);\n    // data chunk length\n    view.setUint32(40, length, true);\n\n    for (let i = 0; i < recorded.length; i += 1) {\n      wav.set(recorded[i], i * bufferLength + 44);\n    }\n\n    recorded = [];\n    const msg = [wav.buffer];\n    postMessage(msg, [msg[0]]);\n  }\n\n  this.onmessage = e => {\n    if (e.data[0] === 'encode') {\n      encode(e.data[1]);\n    } else if (e.data[0] === 'dump') {\n      dump(e.data[1]);\n    } else if (e.data[0] === 'close') {\n      this.close();\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}