{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nvar _jsxFileName = \"/Users/arcsec/Documents/Virufy/virufy-demo.github.io/src/components/MicRecorder/MicRecorder.tsx\",\n    _s = $RefreshSig$();\n\n/* eslint-disable react/require-default-props */\n\n/* eslint-disable jsx-a11y/click-events-have-key-events */\n\n/* eslint-disable jsx-a11y/no-static-element-interactions */\nimport React from 'react';\nimport Timer from 'react-compound-timer';\nimport { useTranslation } from 'react-i18next'; // Utils\n\nimport RecorderService from 'helper/audio/RecorderService';\nimport FileHelper from 'helper/fileHelper';\nimport { getDuration } from 'helper/getDuration'; // Modals\n\nimport RecordErrorModal from 'modals/RecordErrorModal'; // Images\n\nimport StartSVG from \"assets/icons/start.svg\";\nimport StopSVG from \"assets/icons/stop.svg\"; // Styles\n\nimport { MicRecorderContainer, MicRecorderButton, MicRecorderStartImage, MicRecorderStopImage, MicRecorderTimerContainer, MicRecorderTimerReleaseTextContainer, MicRecorderTextP, MicButtonsContainer, MicNote, MicButtonWithText } from './style';\nconst baseConfig = {\n  usingMediaRecorder: false,\n  sampleRate: 48000,\n  manualEncoderId: 'wav',\n  // wav / mp3 / flac\n  processorBufferSize: 2048 // 4096 flac / 2048 wav\n\n};\n\nconst MicRecorder = ({\n  className = '',\n  maxTimeInSeconds = 30,\n  // 30 segs\n  onNewRecord,\n  delay = 500,\n  // 500ms\n  recordingFile\n}) => {\n  _s();\n\n  // Hooks\n  const {\n    t\n  } = useTranslation(); // Refs\n\n  const recordingService = React.useRef();\n  const audioSamples = React.useRef(0);\n  const timerRef = React.useRef();\n  const timeout = React.useRef();\n  const target = React.useRef(); // States\n\n  const [micAllowed, setMicAllowed] = React.useState(true);\n  const [recordingInProgress, setRecordingInProgress] = React.useState();\n  const [showReleaseText, setShowReleaseText] = React.useState(false);\n  const [showShortRecordingText, setShowShortRecordingText] = React.useState(false);\n  const [longPressTriggered, setLongPressTriggered] = React.useState(false); // Handlers\n\n  const onAudioProcess = React.useCallback(e => {\n    audioSamples.current += 1;\n    const {\n      inputBuffer,\n      outputBuffer\n    } = e.detail;\n\n    for (let channel = 0; channel < outputBuffer.numberOfChannels; channel += 1) {\n      const inputData = inputBuffer.getChannelData(channel);\n      const outputData = outputBuffer.getChannelData(channel); // Each sample\n\n      for (let sample = 0; sample < inputBuffer.length; sample += 1) {\n        outputData[sample] = inputData[sample];\n      }\n    }\n  }, []);\n  const onNewRecording = React.useCallback(async e => {\n    const {\n      detail\n    } = e;\n    const {\n      recording\n    } = detail;\n    const blob = await fetch(recording.blobUrl).then(r => r.blob());\n    const fileName = `Filename.${baseConfig.manualEncoderId}`;\n    const file = FileHelper.blobToFile(blob, fileName);\n    const humanReadableSize = FileHelper.sizeAsHuman(file.size, true);\n    onNewRecord(file, humanReadableSize);\n  }, [onNewRecord]); // Effects\n\n  React.useEffect(() => {\n    recordingService.current = new RecorderService({ ...baseConfig,\n      onRecording: onNewRecording,\n      onAudioProcesss: onAudioProcess\n    });\n    const userMediaConstraints = {\n      audio: {\n        echoCancellation: recordingService.current.config.enableEchoCancellation\n      }\n    };\n    navigator.mediaDevices.getUserMedia(userMediaConstraints).then(() => {\n      setMicAllowed(true);\n    }).catch(() => {\n      setMicAllowed(false);\n    });\n\n    if (recordingFile) {\n      const file = recordingFile;\n\n      if (file.size) {\n        const audio = new Audio(URL.createObjectURL(file));\n        audio.load();\n\n        const listenerFn = async () => {\n          audio.removeEventListener('loadedmetadata', listenerFn);\n          getDuration(audio, true).then(result => {\n            var _timerRef$current;\n\n            (_timerRef$current = timerRef.current) === null || _timerRef$current === void 0 ? void 0 : _timerRef$current.setTime(result * 1000);\n          });\n        };\n\n        audio.addEventListener('loadedmetadata', listenerFn);\n      }\n    }\n\n    return () => {\n      if (recordingService.current) {\n        recordingService.current.cleanup();\n      }\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []); // Handlers\n\n  const handleStartRecording = React.useCallback(() => {\n    if (recordingService.current) {\n      audioSamples.current = 0;\n      recordingService.current.startRecording().then(() => {\n        setRecordingInProgress(true);\n        setShowShortRecordingText(false);\n\n        if (timerRef.current) {\n          var _timerRef$current2;\n\n          timerRef.current.reset();\n          (_timerRef$current2 = timerRef.current) === null || _timerRef$current2 === void 0 ? void 0 : _timerRef$current2.setTime(0);\n          timerRef.current.start();\n        }\n      }).catch(error => console.error('ERROR', error));\n    }\n  }, []);\n  const handleStopRecording = React.useCallback(() => {\n    if (recordingService.current) {\n      recordingService.current.stopRecording();\n      setRecordingInProgress(false);\n\n      if (timerRef.current) {\n        if (timerRef.current.getTime() / 1000 < 2) {\n          setShowShortRecordingText(true);\n        }\n\n        timerRef.current.stop();\n      }\n    }\n  }, []);\n  const handleFormatValue = React.useCallback(value => value < 10 ? `0${value}` : value, []);\n\n  const preventDefault = event => {\n    if (!('touches' in event)) event.preventDefault();\n  };\n\n  const handleStartLongPress = React.useCallback(event => {\n    if (event.target) {\n      event.target.addEventListener('touchend', preventDefault, {\n        passive: false\n      });\n      target.current = event.target;\n    }\n\n    timeout.current = setTimeout(() => {\n      setShowReleaseText(true);\n      setLongPressTriggered(true);\n      setShowShortRecordingText(false);\n    }, delay);\n  }, [delay]);\n  const handleEndLongPress = React.useCallback(() => {\n    if (timeout.current) {\n      clearTimeout(timeout.current);\n    }\n\n    if (longPressTriggered) {\n      setShowReleaseText(false);\n    }\n\n    setLongPressTriggered(false);\n\n    if (target.current) {\n      target.current.removeEventListener('touchend', preventDefault);\n    }\n  }, [longPressTriggered]);\n  return /*#__PURE__*/_jsxDEV(MicRecorderContainer, {\n    className: className,\n    children: [/*#__PURE__*/_jsxDEV(MicRecorderTimerReleaseTextContainer, {\n      children: [!showShortRecordingText && /*#__PURE__*/_jsxDEV(MicRecorderTextP, {\n        show: showReleaseText,\n        children: recordingInProgress ? t('recordingsIntroduction:releaseButtonStop') : t('recordingsIntroduction:releaseButtonStart')\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 237,\n        columnNumber: 13\n      }, this), /*#__PURE__*/_jsxDEV(RecordErrorModal, {\n        isOpen: showShortRecordingText,\n        modalTitle: \"Oops.\",\n        onConfirm: handleStartRecording,\n        children: t('recordingsIntroduction:shortRecording')\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 243,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 234,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(MicRecorderTimerContainer, {\n      children: /*#__PURE__*/_jsxDEV(Timer, {\n        ref: timerRef,\n        startImmediately: false,\n        checkpoints: [{\n          time: maxTimeInSeconds * 1000,\n          callback: handleStopRecording\n        }],\n        children: [/*#__PURE__*/_jsxDEV(Timer.Minutes, {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 262,\n          columnNumber: 11\n        }, this), \":\", /*#__PURE__*/_jsxDEV(Timer.Seconds, {\n          formatValue: handleFormatValue\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 264,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 252,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 251,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(MicButtonsContainer, {\n      children: [/*#__PURE__*/_jsxDEV(MicButtonWithText, {\n        children: [/*#__PURE__*/_jsxDEV(MicRecorderButton, {\n          disabled: !micAllowed || recordingInProgress,\n          onClick: handleStartRecording,\n          onMouseDown: handleStartLongPress,\n          onMouseUp: handleEndLongPress,\n          onTouchStart: handleStartLongPress,\n          onTouchEnd: handleEndLongPress,\n          onMouseLeave: handleEndLongPress,\n          children: /*#__PURE__*/_jsxDEV(MicRecorderStartImage, {\n            src: StartSVG,\n            alt: \"Start\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 278,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 269,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(MicNote, {\n          children: t('recordingsIntroduction:recordCough.record')\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 283,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 268,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(MicButtonWithText, {\n        children: [/*#__PURE__*/_jsxDEV(MicRecorderButton, {\n          disabled: !micAllowed || !recordingInProgress,\n          onClick: handleStopRecording,\n          onMouseDown: handleStartLongPress,\n          onMouseUp: handleEndLongPress,\n          onTouchStart: handleStartLongPress,\n          onTouchEnd: handleEndLongPress,\n          onMouseLeave: handleEndLongPress,\n          children: /*#__PURE__*/_jsxDEV(MicRecorderStopImage, {\n            src: StopSVG,\n            alt: \"Stop\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 295,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 286,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(MicNote, {\n          children: t('recordingsIntroduction:recordCough.stop')\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 300,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 285,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 267,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 233,\n    columnNumber: 5\n  }, this);\n};\n\n_s(MicRecorder, \"aRG5ZsxWEknmai7VB6ZT/tfZKBI=\", false, function () {\n  return [useTranslation];\n});\n\n_c = MicRecorder;\nexport default _c2 = /*#__PURE__*/React.memo(MicRecorder);\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"MicRecorder\");\n$RefreshReg$(_c2, \"%default%\");","map":{"version":3,"sources":["/Users/arcsec/Documents/Virufy/virufy-demo.github.io/src/components/MicRecorder/MicRecorder.tsx"],"names":["React","Timer","useTranslation","RecorderService","FileHelper","getDuration","RecordErrorModal","MicRecorderContainer","MicRecorderButton","MicRecorderStartImage","MicRecorderStopImage","MicRecorderTimerContainer","MicRecorderTimerReleaseTextContainer","MicRecorderTextP","MicButtonsContainer","MicNote","MicButtonWithText","baseConfig","usingMediaRecorder","sampleRate","manualEncoderId","processorBufferSize","MicRecorder","className","maxTimeInSeconds","onNewRecord","delay","recordingFile","t","recordingService","useRef","audioSamples","timerRef","timeout","target","micAllowed","setMicAllowed","useState","recordingInProgress","setRecordingInProgress","showReleaseText","setShowReleaseText","showShortRecordingText","setShowShortRecordingText","longPressTriggered","setLongPressTriggered","onAudioProcess","useCallback","e","current","inputBuffer","outputBuffer","detail","channel","numberOfChannels","inputData","getChannelData","outputData","sample","length","onNewRecording","recording","blob","fetch","blobUrl","then","r","fileName","file","blobToFile","humanReadableSize","sizeAsHuman","size","useEffect","onRecording","onAudioProcesss","userMediaConstraints","audio","echoCancellation","config","enableEchoCancellation","navigator","mediaDevices","getUserMedia","catch","Audio","URL","createObjectURL","load","listenerFn","removeEventListener","result","setTime","addEventListener","cleanup","handleStartRecording","startRecording","reset","start","error","console","handleStopRecording","stopRecording","getTime","stop","handleFormatValue","value","preventDefault","event","handleStartLongPress","passive","setTimeout","handleEndLongPress","clearTimeout","time","callback","StartSVG","StopSVG","memo"],"mappings":"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","sourcesContent":["/* eslint-disable react/require-default-props */\n/* eslint-disable jsx-a11y/click-events-have-key-events */\n/* eslint-disable jsx-a11y/no-static-element-interactions */\nimport React from 'react';\nimport Timer from 'react-compound-timer';\nimport { useTranslation } from 'react-i18next';\n\n// Utils\nimport RecorderService from 'helper/audio/RecorderService';\nimport FileHelper from 'helper/fileHelper';\nimport { getDuration } from 'helper/getDuration';\n\n// Modals\nimport RecordErrorModal from 'modals/RecordErrorModal';\n\n// Images\nimport StartSVG from 'assets/icons/start.svg';\nimport StopSVG from 'assets/icons/stop.svg';\n\n// Styles\nimport {\n  MicRecorderContainer,\n  MicRecorderButton,\n  MicRecorderStartImage,\n  MicRecorderStopImage,\n  MicRecorderTimerContainer,\n  MicRecorderTimerReleaseTextContainer,\n  MicRecorderTextP,\n  MicButtonsContainer,\n  MicNote,\n  MicButtonWithText,\n} from './style';\n\ninterface MicRecorderProps {\n  className?: string;\n  maxTimeInSeconds?: number;\n  onNewRecord: (file: File, humanReadableSize: string) => void;\n  delay?: number;\n  recordingFile: any;\n}\n\nconst baseConfig = {\n  usingMediaRecorder: false,\n  sampleRate: 48000,\n  manualEncoderId: 'wav', // wav / mp3 / flac\n  processorBufferSize: 2048, // 4096 flac / 2048 wav\n};\n\nexport interface RecorderServiceType {\n  config: {\n    broadcastAudioProcessEvents: boolean; // default: false\n    createAnalyserNode: boolean; // default: false\n    createDynamicsCompressorNode: boolean; // default: false\n    forceScriptProcessor: false; // default: false\n    manualEncoderId: string; // default: 'wav'\n    micGain: number; // default: 1.0\n    processorBufferSize: number; // default: 2048\n    stopTracksAndCloseCtxWhenFinished: boolean; // default: true\n    usingMediaRecorder: boolean; // default: typeof window.MediaRecorder !== 'undefined'\n    enableEchoCancellation: boolean; // default: true\n    sampleRate: number; // default: 44100\n  };\n  em: DocumentFragment;\n  startRecording: (timeslice?: number) => Promise<void>;\n  stopRecording: () => void;\n  cleanup: () => void;\n}\n\nconst MicRecorder = ({\n  className = '',\n  maxTimeInSeconds = 30, // 30 segs\n  onNewRecord,\n  delay = 500, // 500ms\n  recordingFile,\n}: MicRecorderProps) => {\n  // Hooks\n  const { t } = useTranslation();\n\n  // Refs\n  const recordingService = React.useRef<RecorderServiceType>();\n  const audioSamples = React.useRef<number>(0);\n  const timerRef = React.useRef<any>();\n  const timeout = React.useRef<NodeJS.Timeout>();\n  const target = React.useRef<HTMLButtonElement>();\n\n  // States\n  const [micAllowed, setMicAllowed] = React.useState<boolean>(true);\n  const [recordingInProgress, setRecordingInProgress] = React.useState<boolean>();\n  const [showReleaseText, setShowReleaseText] = React.useState<boolean>(false);\n  const [showShortRecordingText, setShowShortRecordingText] = React.useState<boolean>(false);\n  const [longPressTriggered, setLongPressTriggered] = React.useState<boolean>(false);\n\n  // Handlers\n  const onAudioProcess = React.useCallback((e: any) => {\n    audioSamples.current += 1;\n    const { inputBuffer, outputBuffer } = e.detail;\n    for (let channel = 0; channel < outputBuffer.numberOfChannels; channel += 1) {\n      const inputData = inputBuffer.getChannelData(channel);\n      const outputData = outputBuffer.getChannelData(channel);\n      // Each sample\n      for (let sample = 0; sample < inputBuffer.length; sample += 1) {\n        outputData[sample] = inputData[sample];\n      }\n    }\n  }, []);\n\n  const onNewRecording = React.useCallback(async (e: any) => {\n    const { detail } = e;\n    const { recording } = detail;\n    const blob = await fetch(recording.blobUrl).then(r => r.blob());\n    const fileName = `Filename.${baseConfig.manualEncoderId}`;\n\n    const file = FileHelper.blobToFile(blob, fileName);\n    const humanReadableSize = FileHelper.sizeAsHuman(file.size, true);\n\n    onNewRecord(file, humanReadableSize);\n  }, [onNewRecord]);\n\n  // Effects\n  React.useEffect(() => {\n    recordingService.current = new RecorderService({\n      ...baseConfig,\n      onRecording: onNewRecording,\n      onAudioProcesss: onAudioProcess,\n    }) as RecorderServiceType;\n\n    const userMediaConstraints = {\n      audio: {\n        echoCancellation: recordingService.current.config.enableEchoCancellation,\n      },\n    };\n    navigator.mediaDevices.getUserMedia(userMediaConstraints)\n      .then(() => {\n        setMicAllowed(true);\n      })\n      .catch(() => {\n        setMicAllowed(false);\n      });\n\n    if (recordingFile) {\n      const file = recordingFile as File;\n      if (file.size) {\n        const audio = new Audio(URL.createObjectURL(file));\n        audio.load();\n        const listenerFn = async () => {\n          audio.removeEventListener('loadedmetadata', listenerFn);\n          getDuration(audio, true).then(result => {\n            timerRef.current?.setTime(result * 1000);\n          });\n        };\n        audio.addEventListener('loadedmetadata', listenerFn);\n      }\n    }\n\n    return () => {\n      if (recordingService.current) {\n        recordingService.current.cleanup();\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // Handlers\n  const handleStartRecording = React.useCallback(() => {\n    if (recordingService.current) {\n      audioSamples.current = 0;\n      recordingService.current\n        .startRecording()\n        .then(() => {\n          setRecordingInProgress(true);\n          setShowShortRecordingText(false);\n          if (timerRef.current) {\n            timerRef.current.reset();\n            timerRef.current?.setTime(0);\n            timerRef.current.start();\n          }\n        })\n        .catch((error: any) => console.error('ERROR', error));\n    }\n  }, []);\n\n  const handleStopRecording = React.useCallback(() => {\n    if (recordingService.current) {\n      recordingService.current.stopRecording();\n      setRecordingInProgress(false);\n      if (timerRef.current) {\n        if (timerRef.current.getTime() / 1000 < 2) {\n          setShowShortRecordingText(true);\n        }\n        timerRef.current.stop();\n      }\n    }\n  }, []);\n\n  const handleFormatValue = React.useCallback((value: number) => (value < 10 ? `0${value}` : value), []);\n\n  const preventDefault = (event: any) => {\n    if (!('touches' in event)) event.preventDefault();\n  };\n\n  const handleStartLongPress = React.useCallback(\n    event => {\n      if (event.target) {\n        event.target.addEventListener('touchend', preventDefault, {\n          passive: false,\n        });\n        target.current = event.target;\n      }\n      timeout.current = setTimeout(() => {\n        setShowReleaseText(true);\n        setLongPressTriggered(true);\n        setShowShortRecordingText(false);\n      }, delay);\n    },\n    [delay],\n  );\n\n  const handleEndLongPress = React.useCallback(() => {\n    if (timeout.current) {\n      clearTimeout(timeout.current);\n    }\n    if (longPressTriggered) {\n      setShowReleaseText(false);\n    }\n    setLongPressTriggered(false);\n    if (target.current) {\n      target.current.removeEventListener('touchend', preventDefault);\n    }\n  },\n  [longPressTriggered]);\n\n  return (\n    <MicRecorderContainer className={className}>\n      <MicRecorderTimerReleaseTextContainer>\n        {!showShortRecordingText\n          && (\n            <MicRecorderTextP\n              show={showReleaseText}\n            >\n              {recordingInProgress ? t('recordingsIntroduction:releaseButtonStop') : t('recordingsIntroduction:releaseButtonStart')}\n            </MicRecorderTextP>\n          )}\n        <RecordErrorModal\n          isOpen={showShortRecordingText}\n          modalTitle=\"Oops.\"\n          onConfirm={handleStartRecording}\n        >\n          {t('recordingsIntroduction:shortRecording')}\n        </RecordErrorModal>\n      </MicRecorderTimerReleaseTextContainer>\n      <MicRecorderTimerContainer>\n        <Timer\n          ref={timerRef}\n          startImmediately={false}\n          checkpoints={[\n            {\n              time: maxTimeInSeconds * 1000,\n              callback: handleStopRecording,\n            },\n          ]}\n        >\n          <Timer.Minutes />\n          :\n          <Timer.Seconds formatValue={handleFormatValue} />\n        </Timer>\n      </MicRecorderTimerContainer>\n      <MicButtonsContainer>\n        <MicButtonWithText>\n          <MicRecorderButton\n            disabled={!micAllowed || recordingInProgress}\n            onClick={handleStartRecording}\n            onMouseDown={handleStartLongPress}\n            onMouseUp={handleEndLongPress}\n            onTouchStart={handleStartLongPress}\n            onTouchEnd={handleEndLongPress}\n            onMouseLeave={handleEndLongPress}\n          >\n            <MicRecorderStartImage\n              src={StartSVG}\n              alt=\"Start\"\n            />\n          </MicRecorderButton>\n          <MicNote>{t('recordingsIntroduction:recordCough.record')}</MicNote>\n        </MicButtonWithText>\n        <MicButtonWithText>\n          <MicRecorderButton\n            disabled={!micAllowed || !recordingInProgress}\n            onClick={handleStopRecording}\n            onMouseDown={handleStartLongPress}\n            onMouseUp={handleEndLongPress}\n            onTouchStart={handleStartLongPress}\n            onTouchEnd={handleEndLongPress}\n            onMouseLeave={handleEndLongPress}\n          >\n            <MicRecorderStopImage\n              src={StopSVG}\n              alt=\"Stop\"\n            />\n          </MicRecorderButton>\n          <MicNote>{t('recordingsIntroduction:recordCough.stop')}</MicNote>\n        </MicButtonWithText>\n      </MicButtonsContainer>\n    </MicRecorderContainer>\n  );\n};\n\nexport default React.memo(MicRecorder);\n"]},"metadata":{},"sourceType":"module"}