{"ast":null,"code":"import _classCallCheck from \"/Users/arcsec/virufy-demo.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/arcsec/virufy-demo.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/arcsec/virufy-demo.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/arcsec/virufy-demo.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _regeneratorRuntime from \"/Users/arcsec/virufy-demo.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/arcsec/virufy-demo.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { copyResponse } from 'workbox-core/copyResponse.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from 'workbox-strategies/Strategy.js';\nimport './_version.js';\nvar copyRedirectedCacheableResponsesPlugin = {\n  cacheWillUpdate: function cacheWillUpdate(_ref) {\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var response;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              response = _ref.response;\n\n              if (!response.redirected) {\n                _context.next = 7;\n                break;\n              }\n\n              _context.next = 4;\n              return copyResponse(response);\n\n            case 4:\n              _context.t0 = _context.sent;\n              _context.next = 8;\n              break;\n\n            case 7:\n              _context.t0 = response;\n\n            case 8:\n              return _context.abrupt(\"return\", _context.t0);\n\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }))();\n  }\n};\n/**\n * A [Strategy]{@link module:workbox-strategies.Strategy} implementation\n * specifically designed to work with\n * [PrecacheController]{@link module:workbox-precaching.PrecacheController}\n * to both cache and fetch precached assets.\n *\n * Note: an instance of this class is created automatically when creating a\n * `PrecacheController`; it's generally not necessary to create this yourself.\n *\n * @extends module:workbox-strategies.Strategy\n * @memberof module:workbox-precaching\n */\n\nvar PrecacheStrategy = /*#__PURE__*/function (_Strategy) {\n  _inherits(PrecacheStrategy, _Strategy);\n\n  var _super = _createSuper(PrecacheStrategy);\n\n  /**\n   *\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] Cache name to store and retrieve\n   * requests. Defaults to the cache names provided by\n   * [workbox-core]{@link module:workbox-core.cacheNames}.\n   * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} [options.fetchOptions] Values passed along to the\n   * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\n   * of all fetch() requests made by this strategy.\n   * @param {Object} [options.matchOptions] The\n   * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n   * for any `cache.match()` or `cache.put()` calls made by this strategy.\n   * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n   * get the response from the network if there's a precache miss.\n   */\n  function PrecacheStrategy() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, PrecacheStrategy);\n\n    options.cacheName = cacheNames.getPrecacheName(options.cacheName);\n    _this = _super.call(this, options);\n    _this._fallbackToNetwork = options.fallbackToNetwork === false ? false : true; // Redirected responses cannot be used to satisfy a navigation request, so\n    // any redirected response must be \"copied\" rather than cloned, so the new\n    // response doesn't contain the `redirected` flag. See:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n\n    _this.plugins.push(copyRedirectedCacheableResponsesPlugin);\n\n    return _this;\n  }\n  /**\n   * @private\n   * @param {Request|string} request A request to run this strategy for.\n   * @param {module:workbox-strategies.StrategyHandler} handler The event that\n   *     triggered the request.\n   * @return {Promise<Response>}\n   */\n\n\n  _createClass(PrecacheStrategy, [{\n    key: \"_handle\",\n    value: function () {\n      var _handle2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(request, handler) {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return handler.cacheMatch(request);\n\n              case 2:\n                response = _context2.sent;\n\n                if (response) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                if (!(handler.event && handler.event.type === 'install')) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                _context2.next = 7;\n                return this._handleInstall(request, handler);\n\n              case 7:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 8:\n                _context2.next = 10;\n                return this._handleFetch(request, handler);\n\n              case 10:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 11:\n                return _context2.abrupt(\"return\", response);\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _handle(_x, _x2) {\n        return _handle2.apply(this, arguments);\n      }\n\n      return _handle;\n    }()\n  }, {\n    key: \"_handleFetch\",\n    value: function () {\n      var _handleFetch2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(request, handler) {\n        var response, cacheKey;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!this._fallbackToNetwork) {\n                  _context3.next = 7;\n                  break;\n                }\n\n                if (process.env.NODE_ENV !== 'production') {\n                  logger.warn(\"The precached response for \" + \"\".concat(getFriendlyURL(request.url), \" in \").concat(this.cacheName, \" was not \") + \"found. Falling back to the network instead.\");\n                }\n\n                _context3.next = 4;\n                return handler.fetch(request);\n\n              case 4:\n                response = _context3.sent;\n                _context3.next = 8;\n                break;\n\n              case 7:\n                throw new WorkboxError('missing-precache-entry', {\n                  cacheName: this.cacheName,\n                  url: request.url\n                });\n\n              case 8:\n                if (!(process.env.NODE_ENV !== 'production')) {\n                  _context3.next = 24;\n                  break;\n                }\n\n                _context3.t0 = handler.params && handler.params.cacheKey;\n\n                if (_context3.t0) {\n                  _context3.next = 14;\n                  break;\n                }\n\n                _context3.next = 13;\n                return handler.getCacheKey(request, 'read');\n\n              case 13:\n                _context3.t0 = _context3.sent;\n\n              case 14:\n                cacheKey = _context3.t0;\n                // Workbox is going to handle the route.\n                // print the routing details to the console.\n                logger.groupCollapsed(\"Precaching is responding to: \" + getFriendlyURL(request.url));\n                logger.log(\"Serving the precached url: \".concat(getFriendlyURL(cacheKey.url)));\n                logger.groupCollapsed(\"View request details here.\");\n                logger.log(request);\n                logger.groupEnd();\n                logger.groupCollapsed(\"View response details here.\");\n                logger.log(response);\n                logger.groupEnd();\n                logger.groupEnd();\n\n              case 24:\n                return _context3.abrupt(\"return\", response);\n\n              case 25:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _handleFetch(_x3, _x4) {\n        return _handleFetch2.apply(this, arguments);\n      }\n\n      return _handleFetch;\n    }()\n  }, {\n    key: \"_handleInstall\",\n    value: function () {\n      var _handleInstall2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(request, handler) {\n        var response, responseSafeToPrecache;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return handler.fetchAndCachePut(request);\n\n              case 2:\n                response = _context4.sent;\n                // Any time there's no response, consider it a precaching error.\n                responseSafeToPrecache = Boolean(response); // Also consider it an error if the user didn't pass their own\n                // cacheWillUpdate plugin, and the response is a 400+ (note: this means\n                // that by default opaque responses can be precached).\n\n                if (response && response.status >= 400 && !this._usesCustomCacheableResponseLogic()) {\n                  responseSafeToPrecache = false;\n                }\n\n                if (responseSafeToPrecache) {\n                  _context4.next = 7;\n                  break;\n                }\n\n                throw new WorkboxError('bad-precaching-response', {\n                  url: request.url,\n                  status: response.status\n                });\n\n              case 7:\n                return _context4.abrupt(\"return\", response);\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _handleInstall(_x5, _x6) {\n        return _handleInstall2.apply(this, arguments);\n      }\n\n      return _handleInstall;\n    }()\n    /**\n     * Returns true if any users plugins were added containing their own\n     * `cacheWillUpdate` callback.\n     *\n     * This method indicates whether the default cacheable response logic (i.e.\n     * <400, including opaque responses) should be used. If a custom plugin\n     * with a `cacheWillUpdate` callback is passed, then the strategy should\n     * defer to that plugin's logic.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_usesCustomCacheableResponseLogic\",\n    value: function _usesCustomCacheableResponseLogic() {\n      return this.plugins.some(function (plugin) {\n        return plugin.cacheWillUpdate && plugin !== copyRedirectedCacheableResponsesPlugin;\n      });\n    }\n  }]);\n\n  return PrecacheStrategy;\n}(Strategy);\n\nexport { PrecacheStrategy };","map":{"version":3,"sources":["/Users/arcsec/virufy-demo.github.io/node_modules/workbox-precaching/PrecacheStrategy.js"],"names":["copyResponse","cacheNames","getFriendlyURL","logger","WorkboxError","Strategy","copyRedirectedCacheableResponsesPlugin","cacheWillUpdate","response","redirected","PrecacheStrategy","options","cacheName","getPrecacheName","_fallbackToNetwork","fallbackToNetwork","plugins","push","request","handler","cacheMatch","event","type","_handleInstall","_handleFetch","process","env","NODE_ENV","warn","url","fetch","params","cacheKey","getCacheKey","groupCollapsed","log","groupEnd","fetchAndCachePut","responseSafeToPrecache","Boolean","status","_usesCustomCacheableResponseLogic","some","plugin"],"mappings":"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","sourcesContent":["/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { copyResponse } from 'workbox-core/copyResponse.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from 'workbox-strategies/Strategy.js';\nimport './_version.js';\nconst copyRedirectedCacheableResponsesPlugin = {\n    async cacheWillUpdate({ response }) {\n        return response.redirected ? await copyResponse(response) : response;\n    }\n};\n/**\n * A [Strategy]{@link module:workbox-strategies.Strategy} implementation\n * specifically designed to work with\n * [PrecacheController]{@link module:workbox-precaching.PrecacheController}\n * to both cache and fetch precached assets.\n *\n * Note: an instance of this class is created automatically when creating a\n * `PrecacheController`; it's generally not necessary to create this yourself.\n *\n * @extends module:workbox-strategies.Strategy\n * @memberof module:workbox-precaching\n */\nclass PrecacheStrategy extends Strategy {\n    /**\n     *\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to the cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\n     * of all fetch() requests made by this strategy.\n     * @param {Object} [options.matchOptions] The\n     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\n     * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n     * get the response from the network if there's a precache miss.\n     */\n    constructor(options = {}) {\n        options.cacheName = cacheNames.getPrecacheName(options.cacheName);\n        super(options);\n        this._fallbackToNetwork = options.fallbackToNetwork === false ? false : true;\n        // Redirected responses cannot be used to satisfy a navigation request, so\n        // any redirected response must be \"copied\" rather than cloned, so the new\n        // response doesn't contain the `redirected` flag. See:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n        this.plugins.push(copyRedirectedCacheableResponsesPlugin);\n    }\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {module:workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        const response = await handler.cacheMatch(request);\n        if (!response) {\n            // If this is an `install` event then populate the cache. If this is a\n            // `fetch` event (or any other event) then respond with the cached\n            // response.\n            if (handler.event && handler.event.type === 'install') {\n                return await this._handleInstall(request, handler);\n            }\n            return await this._handleFetch(request, handler);\n        }\n        return response;\n    }\n    async _handleFetch(request, handler) {\n        let response;\n        // Fall back to the network if we don't have a cached response\n        // (perhaps due to manual cache cleanup).\n        if (this._fallbackToNetwork) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.warn(`The precached response for ` +\n                    `${getFriendlyURL(request.url)} in ${this.cacheName} was not ` +\n                    `found. Falling back to the network instead.`);\n            }\n            response = await handler.fetch(request);\n        }\n        else {\n            // This shouldn't normally happen, but there are edge cases:\n            // https://github.com/GoogleChrome/workbox/issues/1441\n            throw new WorkboxError('missing-precache-entry', {\n                cacheName: this.cacheName,\n                url: request.url,\n            });\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            const cacheKey = handler.params && handler.params.cacheKey ||\n                await handler.getCacheKey(request, 'read');\n            // Workbox is going to handle the route.\n            // print the routing details to the console.\n            logger.groupCollapsed(`Precaching is responding to: ` +\n                getFriendlyURL(request.url));\n            logger.log(`Serving the precached url: ${getFriendlyURL(cacheKey.url)}`);\n            logger.groupCollapsed(`View request details here.`);\n            logger.log(request);\n            logger.groupEnd();\n            logger.groupCollapsed(`View response details here.`);\n            logger.log(response);\n            logger.groupEnd();\n            logger.groupEnd();\n        }\n        return response;\n    }\n    async _handleInstall(request, handler) {\n        const response = await handler.fetchAndCachePut(request);\n        // Any time there's no response, consider it a precaching error.\n        let responseSafeToPrecache = Boolean(response);\n        // Also consider it an error if the user didn't pass their own\n        // cacheWillUpdate plugin, and the response is a 400+ (note: this means\n        // that by default opaque responses can be precached).\n        if (response && response.status >= 400 &&\n            !this._usesCustomCacheableResponseLogic()) {\n            responseSafeToPrecache = false;\n        }\n        if (!responseSafeToPrecache) {\n            // Throwing here will lead to the `install` handler failing, which\n            // we want to do if *any* of the responses aren't safe to cache.\n            throw new WorkboxError('bad-precaching-response', {\n                url: request.url,\n                status: response.status,\n            });\n        }\n        return response;\n    }\n    /**\n     * Returns true if any users plugins were added containing their own\n     * `cacheWillUpdate` callback.\n     *\n     * This method indicates whether the default cacheable response logic (i.e.\n     * <400, including opaque responses) should be used. If a custom plugin\n     * with a `cacheWillUpdate` callback is passed, then the strategy should\n     * defer to that plugin's logic.\n     *\n     * @private\n     */\n    _usesCustomCacheableResponseLogic() {\n        return this.plugins.some((plugin) => plugin.cacheWillUpdate &&\n            plugin !== copyRedirectedCacheableResponsesPlugin);\n    }\n}\nexport { PrecacheStrategy };\n"]},"metadata":{},"sourceType":"module"}