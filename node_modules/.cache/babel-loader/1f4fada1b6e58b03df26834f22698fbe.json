{"ast":null,"code":"/* eslint-disable */ /* eslint-disable func-names */ /* global Flac */export default function(){var workersHost=process.env.PUBLIC_URL||process.env.REACT_APP_WORKERS_HOST||'https://virufy.org/demo';importScripts(\"\".concat(workersHost,\"/workers/encoders/libflac.dev.js\"));// eslint-disable-line\nvar flacEncoder;var CHANNELS=1;var SAMPLERATE=44100;var COMPRESSION=5;var BPS=16;var flacOk=1;var flacLength=0;var flacBuffers=[];var INIT=false;var wavBuffers=[];// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction writeCallbackFn(buffer,bytes){flacBuffers.push(buffer);flacLength+=buffer.byteLength;}// HELPER: handle initialization of flac encoder\nfunction initFlac(){flacEncoder=Flac.init_libflac_encoder(SAMPLERATE,CHANNELS,BPS,COMPRESSION,0);/// /\nif(flacEncoder!==0){var statusEncoder=Flac.init_encoder_stream(flacEncoder,writeCallbackFn);flacOk&=statusEncoder==0;console.log(\"flac init     : \".concat(flacOk));// DEBUG\nconsole.log(\"status encoder: \".concat(statusEncoder));// DEBUG\nINIT=true;}else{console.error('Error initializing the encoder.');}}function init(config){var finalConfig=config;if(!finalConfig){finalConfig={bps:BPS,channels:CHANNELS,samplerate:SAMPLERATE,compression:COMPRESSION};}finalConfig.channels=finalConfig.channels?finalConfig.channels:CHANNELS;finalConfig.samplerate=finalConfig.samplerate?finalConfig.samplerate:SAMPLERATE;finalConfig.bps=finalConfig.bps?finalConfig.bps:BPS;finalConfig.compression=finalConfig.compression?finalConfig.compression:COMPRESSION;/// /\nCOMPRESSION=finalConfig.compression;BPS=finalConfig.bps;SAMPLERATE=finalConfig.samplerate;CHANNELS=finalConfig.channels;/// /\nif(!Flac.isReady()){Flac.onready=function(){setTimeout(function(){initFlac();},0);};}else{initFlac();}}// HELPER: actually encode PCM data to Flac\nfunction doEncodeFlac(audioData){var bufLength=audioData.length;var bufferI32=new Uint32Array(bufLength);var view=new DataView(bufferI32.buffer);var volume=1;var index=0;for(var i=0;i<bufLength;i+=1){view.setInt32(index,audioData[i]*(0x7FFF*volume),true);index+=4;}var flacReturn=Flac.FLAC__stream_encoder_process_interleaved(flacEncoder,bufferI32,bufferI32.length/CHANNELS);if(flacReturn!=true){console.log(\"Error: encode_buffer_pcm_as_flac returned false. \".concat(flacReturn));}}// HELPER: handle incoming PCM audio data for Flac encoding:\nfunction encodeFlac(audioData){if(!Flac.isReady()){// if Flac is not ready yet: buffer the audio\nwavBuffers.push(audioData);console.info('buffered audio data for Flac encdoing');}else{if(wavBuffers.length>0){// if there is buffered audio: encode buffered first (and clear buffer)\nvar len=wavBuffers.length;var buffered=wavBuffers.splice(0,len);// eslint-disable-next-line no-plusplus\nfor(var i=0;i<len;++i){doEncodeFlac(buffered[i]);}}doEncodeFlac(audioData);}}function mergeBuffersUint8(channelBuffer,recordingLength){var result=new Uint8Array(recordingLength);var offset=0;var lng=channelBuffer.length;for(var i=0;i<lng;i+=1){var buffer=channelBuffer[i];result.set(buffer,offset);offset+=buffer.length;}return result;}function exportFlacFile(recBuffers,recLength){// convert buffers into one single buffer\nvar samples=mergeBuffersUint8(recBuffers,recLength);// var audioBlob = new Blob([samples], { type: type });\nvar theBlob=new Blob([samples],{type:'audio/flac'});return theBlob;}/*\n   * clear recording buffers\n   */function clear(){flacBuffers.splice(0,flacBuffers.length);flacLength=0;wavBuffers.splice(0,wavBuffers.length);}this.onmessage=function onmessage(e){if(e.data[0]==='init'){init(e.data[1]);}else if(e.data[0]==='encode'){encodeFlac(e.data[1]);}else if(e.data[0]==='dump'){var data;if(!Flac.isReady()){console.error('Flac was not initialized: could not encode data!');}else{flacOk&=Flac.FLAC__stream_encoder_finish(flacEncoder);console.log(\"flac finish: \".concat(flacOk));// DEBUG\ndata=exportFlacFile(flacBuffers,flacLength);Flac.FLAC__stream_encoder_delete(flacEncoder);}clear();postMessage(data);INIT=false;}};}","map":null,"metadata":{},"sourceType":"module"}