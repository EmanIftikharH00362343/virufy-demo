{"ast":null,"code":"/* eslint-disable */ /* eslint-disable func-names */ /* global Flac */export default function(){var workersHost=process.env.PUBLIC_URL||process.env.REACT_APP_WORKERS_HOST||'https://virufy.org/demo';importScripts(\"\".concat(workersHost,\"/workers/encoders/libflac.dev.js\"));// eslint-disable-line\nvar flacEncoder;var CHANNELS=1;var SAMPLERATE=44100;var COMPRESSION=5;var BPS=16;var flacOk=1;var flacLength=0;var flacBuffers=[];var INIT=false;var wavBuffers=[];// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction writeCallbackFn(buffer,bytes){flacBuffers.push(buffer);flacLength+=buffer.byteLength;}// HELPER: handle initialization of flac encoder\nfunction initFlac(){flacEncoder=Flac.init_libflac_encoder(SAMPLERATE,CHANNELS,BPS,COMPRESSION,0);/// /\nif(flacEncoder!==0){var statusEncoder=Flac.init_encoder_stream(flacEncoder,writeCallbackFn);flacOk&=statusEncoder==0;console.log(\"flac init     : \".concat(flacOk));// DEBUG\nconsole.log(\"status encoder: \".concat(statusEncoder));// DEBUG\nINIT=true;}else{console.error('Error initializing the encoder.');}}function init(config){var finalConfig=config;if(!finalConfig){finalConfig={bps:BPS,channels:CHANNELS,samplerate:SAMPLERATE,compression:COMPRESSION};}finalConfig.channels=finalConfig.channels?finalConfig.channels:CHANNELS;finalConfig.samplerate=finalConfig.samplerate?finalConfig.samplerate:SAMPLERATE;finalConfig.bps=finalConfig.bps?finalConfig.bps:BPS;finalConfig.compression=finalConfig.compression?finalConfig.compression:COMPRESSION;/// /\nCOMPRESSION=finalConfig.compression;BPS=finalConfig.bps;SAMPLERATE=finalConfig.samplerate;CHANNELS=finalConfig.channels;/// /\nif(!Flac.isReady()){Flac.onready=function(){setTimeout(function(){initFlac();},0);};}else{initFlac();}}// HELPER: actually encode PCM data to Flac\nfunction doEncodeFlac(audioData){var bufLength=audioData.length;var bufferI32=new Uint32Array(bufLength);var view=new DataView(bufferI32.buffer);var volume=1;var index=0;for(var i=0;i<bufLength;i+=1){view.setInt32(index,audioData[i]*(0x7FFF*volume),true);index+=4;}var flacReturn=Flac.FLAC__stream_encoder_process_interleaved(flacEncoder,bufferI32,bufferI32.length/CHANNELS);if(flacReturn!=true){console.log(\"Error: encode_buffer_pcm_as_flac returned false. \".concat(flacReturn));}}// HELPER: handle incoming PCM audio data for Flac encoding:\nfunction encodeFlac(audioData){if(!Flac.isReady()){// if Flac is not ready yet: buffer the audio\nwavBuffers.push(audioData);console.info('buffered audio data for Flac encdoing');}else{if(wavBuffers.length>0){// if there is buffered audio: encode buffered first (and clear buffer)\nvar len=wavBuffers.length;var buffered=wavBuffers.splice(0,len);// eslint-disable-next-line no-plusplus\nfor(var i=0;i<len;++i){doEncodeFlac(buffered[i]);}}doEncodeFlac(audioData);}}function mergeBuffersUint8(channelBuffer,recordingLength){var result=new Uint8Array(recordingLength);var offset=0;var lng=channelBuffer.length;for(var i=0;i<lng;i+=1){var buffer=channelBuffer[i];result.set(buffer,offset);offset+=buffer.length;}return result;}function exportFlacFile(recBuffers,recLength){// convert buffers into one single buffer\nvar samples=mergeBuffersUint8(recBuffers,recLength);// var audioBlob = new Blob([samples], { type: type });\nvar theBlob=new Blob([samples],{type:'audio/flac'});return theBlob;}/*\n   * clear recording buffers\n   */function clear(){flacBuffers.splice(0,flacBuffers.length);flacLength=0;wavBuffers.splice(0,wavBuffers.length);}this.onmessage=function onmessage(e){if(e.data[0]==='init'){init(e.data[1]);}else if(e.data[0]==='encode'){encodeFlac(e.data[1]);}else if(e.data[0]==='dump'){var data;if(!Flac.isReady()){console.error('Flac was not initialized: could not encode data!');}else{flacOk&=Flac.FLAC__stream_encoder_finish(flacEncoder);console.log(\"flac finish: \".concat(flacOk));// DEBUG\ndata=exportFlacFile(flacBuffers,flacLength);Flac.FLAC__stream_encoder_delete(flacEncoder);}clear();postMessage(data);INIT=false;}};}","map":{"version":3,"sources":["/home/amil/virufy-demo.github.io/src/helper/audio/encoder-flac-worker.js"],"names":["workersHost","process","env","PUBLIC_URL","REACT_APP_WORKERS_HOST","importScripts","flacEncoder","CHANNELS","SAMPLERATE","COMPRESSION","BPS","flacOk","flacLength","flacBuffers","INIT","wavBuffers","writeCallbackFn","buffer","bytes","push","byteLength","initFlac","Flac","init_libflac_encoder","statusEncoder","init_encoder_stream","console","log","error","init","config","finalConfig","bps","channels","samplerate","compression","isReady","onready","setTimeout","doEncodeFlac","audioData","bufLength","length","bufferI32","Uint32Array","view","DataView","volume","index","i","setInt32","flacReturn","FLAC__stream_encoder_process_interleaved","encodeFlac","info","len","buffered","splice","mergeBuffersUint8","channelBuffer","recordingLength","result","Uint8Array","offset","lng","set","exportFlacFile","recBuffers","recLength","samples","theBlob","Blob","type","clear","onmessage","e","data","FLAC__stream_encoder_finish","FLAC__stream_encoder_delete","postMessage"],"mappings":"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","sourcesContent":["/* eslint-disable */\n/* eslint-disable func-names */\n/* global Flac */\n\nexport default function () {\n  const workersHost = process.env.PUBLIC_URL || process.env.REACT_APP_WORKERS_HOST || 'https://virufy.org/demo';\n  importScripts(`${workersHost}/workers/encoders/libflac.dev.js`); // eslint-disable-line\n\n  let flacEncoder;\n  let CHANNELS = 1;\n  let SAMPLERATE = 44100;\n  let COMPRESSION = 5;\n  let BPS = 16;\n  let flacOk = 1;\n  let flacLength = 0;\n  const flacBuffers = [];\n  let INIT = false;\n  const wavBuffers = [];\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  function writeCallbackFn(buffer, bytes) {\n    flacBuffers.push(buffer);\n    flacLength += buffer.byteLength;\n  }\n\n  // HELPER: handle initialization of flac encoder\n  function initFlac() {\n    flacEncoder = Flac.init_libflac_encoder(SAMPLERATE, CHANNELS, BPS, COMPRESSION, 0);\n    /// /\n    if (flacEncoder !== 0) {\n      const statusEncoder = Flac.init_encoder_stream(flacEncoder, writeCallbackFn);\n      flacOk &= (statusEncoder == 0);\n\n      console.log(`flac init     : ${flacOk}`);// DEBUG\n      console.log(`status encoder: ${statusEncoder}`);// DEBUG\n\n      INIT = true;\n    } else {\n      console.error('Error initializing the encoder.');\n    }\n  }\n\n  function init(config) {\n    let finalConfig = config;\n\n    if (!finalConfig) {\n      finalConfig = {\n        bps: BPS, channels: CHANNELS, samplerate: SAMPLERATE, compression: COMPRESSION,\n      };\n    }\n\n    finalConfig.channels = finalConfig.channels ? finalConfig.channels : CHANNELS;\n    finalConfig.samplerate = finalConfig.samplerate ? finalConfig.samplerate : SAMPLERATE;\n    finalConfig.bps = finalConfig.bps ? finalConfig.bps : BPS;\n    finalConfig.compression = finalConfig.compression ? finalConfig.compression : COMPRESSION;\n\n    /// /\n    COMPRESSION = finalConfig.compression;\n    BPS = finalConfig.bps;\n    SAMPLERATE = finalConfig.samplerate;\n    CHANNELS = finalConfig.channels;\n    /// /\n\n    if (!Flac.isReady()) {\n      Flac.onready = function () {\n        setTimeout(() => {\n          initFlac();\n        }, 0);\n      };\n    } else {\n      initFlac();\n    }\n  }\n\n  // HELPER: actually encode PCM data to Flac\n  function doEncodeFlac(audioData) {\n    const bufLength = audioData.length;\n    const bufferI32 = new Uint32Array(bufLength);\n    const view = new DataView(bufferI32.buffer);\n    const volume = 1;\n    let index = 0;\n    for (let i = 0; i < bufLength; i += 1) {\n      view.setInt32(index, (audioData[i] * (0x7FFF * volume)), true);\n      index += 4;\n    }\n\n    const flacReturn = Flac.FLAC__stream_encoder_process_interleaved(\n      flacEncoder, bufferI32, bufferI32.length / CHANNELS,\n    );\n    if (flacReturn != true) {\n      console.log(`Error: encode_buffer_pcm_as_flac returned false. ${flacReturn}`);\n    }\n  }\n\n  // HELPER: handle incoming PCM audio data for Flac encoding:\n  function encodeFlac(audioData) {\n    if (!Flac.isReady()) {\n      // if Flac is not ready yet: buffer the audio\n      wavBuffers.push(audioData);\n      console.info('buffered audio data for Flac encdoing');\n    } else {\n      if (wavBuffers.length > 0) {\n        // if there is buffered audio: encode buffered first (and clear buffer)\n\n        const len = wavBuffers.length;\n        const buffered = wavBuffers.splice(0, len);\n        // eslint-disable-next-line no-plusplus\n        for (let i = 0; i < len; ++i) {\n          doEncodeFlac(buffered[i]);\n        }\n      }\n\n      doEncodeFlac(audioData);\n    }\n  }\n\n  function mergeBuffersUint8(channelBuffer, recordingLength) {\n    const result = new Uint8Array(recordingLength);\n    let offset = 0;\n    const lng = channelBuffer.length;\n    for (let i = 0; i < lng; i += 1) {\n      const buffer = channelBuffer[i];\n      result.set(buffer, offset);\n      offset += buffer.length;\n    }\n    return result;\n  }\n\n  function exportFlacFile(recBuffers, recLength) {\n    // convert buffers into one single buffer\n    const samples = mergeBuffersUint8(recBuffers, recLength);\n\n    // var audioBlob = new Blob([samples], { type: type });\n    const theBlob = new Blob([samples], { type: 'audio/flac' });\n    return theBlob;\n  }\n\n  /*\n   * clear recording buffers\n   */\n  function clear() {\n    flacBuffers.splice(0, flacBuffers.length);\n    flacLength = 0;\n    wavBuffers.splice(0, wavBuffers.length);\n  }\n\n  this.onmessage = function onmessage(e) {\n    if (e.data[0] === 'init') {\n      init(e.data[1]);\n    } else if (e.data[0] === 'encode') {\n      encodeFlac(e.data[1]);\n    } else if (e.data[0] === 'dump') {\n      let data;\n      if (!Flac.isReady()) {\n        console.error('Flac was not initialized: could not encode data!');\n      } else {\n        flacOk &= Flac.FLAC__stream_encoder_finish(flacEncoder);\n        console.log(`flac finish: ${flacOk}`);// DEBUG\n        data = exportFlacFile(flacBuffers, flacLength);\n\n        Flac.FLAC__stream_encoder_delete(flacEncoder);\n      }\n\n      clear();\n\n      postMessage(data);\n      INIT = false;\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}