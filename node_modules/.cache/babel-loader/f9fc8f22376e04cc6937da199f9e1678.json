{"ast":null,"code":"/* eslint-disable func-names */\nexport default function () {\n  // Parts copied from https://github.com/chris-rudmin/Recorderjs\n  const BYTES_PER_SAMPLE = 2;\n  const CHANNELS = 1; // 1=mono , 2=Stereo\n\n  let recorded = [];\n\n  function encode(buffer) {\n    const {\n      length\n    } = buffer;\n    const data = new Uint8Array(length * BYTES_PER_SAMPLE * CHANNELS);\n\n    for (let i = 0; i < length; i += 1) {\n      const index = i * BYTES_PER_SAMPLE * CHANNELS;\n      let sample = buffer[i];\n\n      if (sample > 1) {\n        sample = 1;\n      } else if (sample < -1) {\n        sample = -1;\n      }\n\n      sample *= 32768;\n      data[index] = sample; // eslint-disable-next-line no-bitwise\n\n      data[index + 1] = sample >> 8;\n    }\n\n    recorded.push(data);\n  }\n\n  function dump(sampleRate) {\n    const bufferLength = recorded.length ? recorded[0].length : 0;\n    const length = recorded.length * bufferLength;\n    const wav = new Uint8Array(44 + length);\n    const view = new DataView(wav.buffer); // RIFF identifier 'RIFF'\n\n    view.setUint32(0, 1380533830, false); // file length minus RIFF identifier length and file description length\n\n    view.setUint32(4, 36 + length, true); // RIFF type 'WAVE'\n\n    view.setUint32(8, 1463899717, false); // format chunk identifier 'fmt '\n\n    view.setUint32(12, 1718449184, false); // format chunk length\n\n    view.setUint32(16, 16, true); // sample format (raw)\n\n    view.setUint16(20, 1, true); // channel count\n\n    view.setUint16(22, CHANNELS, true); // sample rate\n\n    view.setUint32(24, sampleRate, true); // 44100 Khz\n    // byte rate (channels * sample rate * block align)\n\n    view.setUint32(28, CHANNELS * sampleRate * BYTES_PER_SAMPLE, true); // kbps = 1411\n    // block align (channel count * bytes per sample)\n\n    view.setUint16(32, CHANNELS * BYTES_PER_SAMPLE, true); // bits per sample\n\n    view.setUint16(34, 8 * BYTES_PER_SAMPLE, true); // 16\n    // data chunk identifier 'data'\n\n    view.setUint32(36, 1684108385, false); // data chunk length\n\n    view.setUint32(40, length, true);\n\n    for (let i = 0; i < recorded.length; i += 1) {\n      wav.set(recorded[i], i * bufferLength + 44);\n    }\n\n    recorded = [];\n    const msg = [wav.buffer];\n    postMessage(msg, [msg[0]]);\n  }\n\n  this.onmessage = e => {\n    if (e.data[0] === 'encode') {\n      encode(e.data[1]);\n    } else if (e.data[0] === 'dump') {\n      dump(e.data[1]);\n    } else if (e.data[0] === 'close') {\n      this.close();\n    }\n  };\n}","map":{"version":3,"sources":["/Users/arcsec/Documents/Virufy/virufy-demo.github.io/src/helper/audio/encoder-wav-worker.js"],"names":["BYTES_PER_SAMPLE","CHANNELS","recorded","encode","buffer","length","data","Uint8Array","i","index","sample","push","dump","sampleRate","bufferLength","wav","view","DataView","setUint32","setUint16","set","msg","postMessage","onmessage","e","close"],"mappings":"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","sourcesContent":["/* eslint-disable func-names */\nexport default function () {\n  // Parts copied from https://github.com/chris-rudmin/Recorderjs\n  const BYTES_PER_SAMPLE = 2;\n  const CHANNELS = 1; // 1=mono , 2=Stereo\n  let recorded = [];\n\n  function encode(buffer) {\n    const { length } = buffer;\n    const data = new Uint8Array(length * BYTES_PER_SAMPLE * CHANNELS);\n    for (let i = 0; i < length; i += 1) {\n      const index = i * BYTES_PER_SAMPLE * CHANNELS;\n      let sample = buffer[i];\n      if (sample > 1) {\n        sample = 1;\n      } else if (sample < -1) {\n        sample = -1;\n      }\n      sample *= 32768;\n      data[index] = sample;\n      // eslint-disable-next-line no-bitwise\n      data[index + 1] = sample >> 8;\n    }\n    recorded.push(data);\n  }\n\n  function dump(sampleRate) {\n    const bufferLength = recorded.length ? recorded[0].length : 0;\n    const length = recorded.length * bufferLength;\n    const wav = new Uint8Array(44 + length);\n\n    const view = new DataView(wav.buffer);\n\n    // RIFF identifier 'RIFF'\n    view.setUint32(0, 1380533830, false);\n    // file length minus RIFF identifier length and file description length\n    view.setUint32(4, 36 + length, true);\n    // RIFF type 'WAVE'\n    view.setUint32(8, 1463899717, false);\n    // format chunk identifier 'fmt '\n    view.setUint32(12, 1718449184, false);\n    // format chunk length\n    view.setUint32(16, 16, true);\n    // sample format (raw)\n    view.setUint16(20, 1, true);\n    // channel count\n    view.setUint16(22, CHANNELS, true);\n    // sample rate\n    view.setUint32(24, sampleRate, true); // 44100 Khz\n    // byte rate (channels * sample rate * block align)\n    view.setUint32(28, CHANNELS * sampleRate * BYTES_PER_SAMPLE, true); // kbps = 1411\n    // block align (channel count * bytes per sample)\n    view.setUint16(32, CHANNELS * BYTES_PER_SAMPLE, true);\n    // bits per sample\n    view.setUint16(34, 8 * BYTES_PER_SAMPLE, true); // 16\n    // data chunk identifier 'data'\n    view.setUint32(36, 1684108385, false);\n    // data chunk length\n    view.setUint32(40, length, true);\n\n    for (let i = 0; i < recorded.length; i += 1) {\n      wav.set(recorded[i], i * bufferLength + 44);\n    }\n\n    recorded = [];\n    const msg = [wav.buffer];\n    postMessage(msg, [msg[0]]);\n  }\n\n  this.onmessage = e => {\n    if (e.data[0] === 'encode') {\n      encode(e.data[1]);\n    } else if (e.data[0] === 'dump') {\n      dump(e.data[1]);\n    } else if (e.data[0] === 'close') {\n      this.close();\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}