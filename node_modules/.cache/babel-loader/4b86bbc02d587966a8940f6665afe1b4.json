{"ast":null,"code":"import _classCallCheck from\"/Users/arcsec/Documents/Virufy/virufy-demo.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";/* eslint-disable max-len */ /* eslint-disable consistent-return */ /* eslint-disable no-underscore-dangle */ // Vendor Library https://github.com/mogwai/pwa-audio-recorder/tree/master\nimport EncoderWav from'./encoder-wav-worker';import EncoderMp3 from'./encoder-mp3-worker';import EncoderFlac from'./encoder-flac-worker';// import EncoderOgg from './encoder-ogg-worker';\nvar RecorderService=function RecorderService(config){var _this=this;_classCallCheck(this,RecorderService);this.cleanup=function(){if(_this.config.onRecording){_this.em.removeEventListener('recording',_this.recordingFn);}if(_this.config.onAudioProcesss){_this.em.removeEventListener('onaudioprocess',_this.onAudioProcessFn);}};this.createWorker=function(fn){var js=fn.toString().replace(/^function\\s*\\(\\)\\s*{/,'').replace(/}$/,'');var blob=new Blob([js]);return new Worker(URL.createObjectURL(blob));};this.startRecording=function(timeslice){if(_this.state!=='inactive'){return;}// This is the case on ios/chrome, when clicking links from within ios/slack (sometimes), etc.\nif(!navigator||!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia){// alert('Missing support for navigator.mediaDevices.getUserMedia'); // temp: helps when testing for strange issues on ios/safari\nreturn;}_this.audioCtx=new AudioContext({sampleRate:_this.config.sampleRate});_this.micGainNode=_this.audioCtx.createGain();_this.outputGainNode=_this.audioCtx.createGain();if(_this.config.createDynamicsCompressorNode){_this.dynamicsCompressorNode=_this.audioCtx.createDynamicsCompressor();}if(_this.config.createAnalyserNode){_this.analyserNode=_this.audioCtx.createAnalyser();}// If not using MediaRecorder(i.e. safari and edge), then a script processor is required. It's optional\n// on browsers using MediaRecorder and is only useful if wanting to do custom analysis or manipulation of\n// recorded audio data.\nif(_this.config.forceScriptProcessor||_this.config.broadcastAudioProcessEvents||!_this.config.usingMediaRecorder){_this.processorNode=_this.audioCtx.createScriptProcessor(_this.config.processorBufferSize,1,1);// TODO: Get the number of channels from mic\n}// Create stream destination on chrome/firefox because, AFAICT, we have no other way of feeding audio graph output\n// in to MediaRecorderSafari/Edge don't have this method as of 2018-04.\nif(_this.audioCtx.createMediaStreamDestination){_this.destinationNode=_this.audioCtx.createMediaStreamDestination();}else{_this.destinationNode=_this.audioCtx.destination;}// Create web worker for doing the encoding\nif(!_this.config.usingMediaRecorder){if(_this.config.manualEncoderId==='mp3'){_this.encoderWorker=_this.createWorker(EncoderMp3);var baseUrl=process.env.PUBLIC_URL||'https://virufy.org/demo';_this.encoderWorker.postMessage(['init',{baseUrl:baseUrl,sampleRate:_this.audioCtx.sampleRate}]);_this.encoderMimeType='audio/mpeg';}else if(_this.config.manualEncoderId==='flac'){_this.encoderWorker=_this.createWorker(EncoderFlac);_this.encoderWorker.postMessage(['init',{sampleRate:_this.audioCtx.sampleRate}]);_this.encoderMimeType='audio/flac';}else{_this.encoderWorker=_this.createWorker(EncoderWav);_this.encoderMimeType='audio/wav';}_this.encoderWorker.addEventListener('message',function(e){var event=new Event('dataavailable');if(_this.config.manualEncoderId==='ogg'||_this.config.manualEncoderId==='flac'){event.data=e.data;}else{event.data=new Blob(e.data,{type:_this.encoderMimeType});}_this._onDataAvailable(event);});}// Setup media constraints\nvar userMediaConstraints={audio:{echoCancellation:_this.config.enableEchoCancellation}};if(_this.config.deviceId){userMediaConstraints.audio.deviceId=_this.config.deviceId;}// This will prompt user for permission if needed\nreturn navigator.mediaDevices.getUserMedia(userMediaConstraints).then(function(stream){_this._startRecordingWithStream(stream,timeslice);}).catch(function(error){// alert(`Error with getUserMedia: ${error.message}`); // temp: helps when testing for strange issues on ios/safari\nconsole.log(error);});};this.setMicGain=function(newGain){_this.config.micGain=newGain;if(_this.audioCtx&&_this.micGainNode){_this.micGainNode.gain.setValueAtTime(newGain,_this.audioCtx.currentTime);}};this._startRecordingWithStream=function(stream,timeslice){_this.micAudioStream=stream;_this.inputStreamNode=_this.audioCtx.createMediaStreamSource(_this.micAudioStream);_this.audioCtx=_this.inputStreamNode.context;// Kind-of a hack to allow hooking in to audioGraph inputStreamNode\nif(_this.onGraphSetupWithInputStream){_this.onGraphSetupWithInputStream(_this.inputStreamNode);}_this.inputStreamNode.connect(_this.micGainNode);_this.micGainNode.gain.setValueAtTime(_this.config.micGain,_this.audioCtx.currentTime);var nextNode=_this.micGainNode;if(_this.dynamicsCompressorNode){_this.micGainNode.connect(_this.dynamicsCompressorNode);nextNode=_this.dynamicsCompressorNode;}_this.state='recording';if(_this.processorNode){nextNode.connect(_this.processorNode);_this.processorNode.connect(_this.outputGainNode);_this.processorNode.onaudioprocess=function(e){return _this._onAudioProcess(e);};}else{nextNode.connect(_this.outputGainNode);}if(_this.analyserNode){// TODO: If we want the analyser node to receive the processorNode's output, this needs to be changed _and_\n//       processor node needs to be modified to copy input to output. It currently doesn't because it's not\n//       needed when doing manual encoding.\n// this.processorNode.connect(this.analyserNode)\nnextNode.connect(_this.analyserNode);}_this.outputGainNode.connect(_this.destinationNode);if(_this.config.usingMediaRecorder){_this.mediaRecorder=new MediaRecorder(_this.destinationNode.stream,{mimeType:_this.encoderMimeType||'audio/wav'});_this.mediaRecorder.addEventListener('dataavailable',function(evt){return _this._onDataAvailable(evt);});_this.mediaRecorder.addEventListener('error',function(evt){return _this._onError(evt);});_this.mediaRecorder.start(timeslice);}else{// Output gain to zero to prevent feedback. Seems to matter only on Edge, though seems like should matter\n// on iOS too.  Matters on chrome when connecting graph to directly to audioCtx.destination, but we are\n// not able to do that when using MediaRecorder.\n_this.outputGainNode.gain.setValueAtTime(0,_this.audioCtx.currentTime);// this.outputGainNode.gain.value = 0\n// Todo: Note that time slicing with manual wav encoderWav won't work. To allow it would require rewriting the encoderWav\n// to assemble all chunks at end instead of adding header to each chunk.\nif(timeslice){console.log('Time slicing without MediaRecorder is not yet supported. The resulting recording will not be playable.');_this.slicing=setInterval(function anon(){if(this.state==='recording'){this.encoderWorker.postMessage(['dump',this.context.sampleRate]);}},timeslice);}}};this._onAudioProcess=function(e){// console.log('onaudioprocess', e)\n// let inputBuffer = e.inputBuffer\n// let outputBuffer = e.outputBuffer\n// console.log(this.micAudioStream)\n// console.log(this.audioCtx)\n// console.log(this.micAudioStream.getTracks().forEach((track) => console.log(track)))\n// this.onAudioEm.dispatch(new Event('onaudioprocess', {inputBuffer:inputBuffer,outputBuffer:outputBuffer}))\nif(_this.config.broadcastAudioProcessEvents){_this.em.dispatchEvent(new CustomEvent('onaudioprocess',{detail:{inputBuffer:e.inputBuffer,outputBuffer:e.outputBuffer}}));}// // Example handling:\n// let inputBuffer = e.inputBuffer\n// let outputBuffer = e.outputBuffer\n// // Each channel (usually only one)\n// for (let channel = 0; channel < outputBuffer.numberOfChannels; channel++) {\n//   let inputData = inputBuffer.getChannelData(channel)\n//   let outputData = outputBuffer.getChannelData(channel)\n//\n//   // Each sample\n//   for (let sample = 0; sample < inputBuffer.length; sample++) {\n//     // Make output equal to the same as the input (thus processor is doing nothing at this time)\n//     outputData[sample] = inputData[sample]\n//   }\n// }\n// When manually encoding (safari/edge), there's no reason to copy data to output buffer.  We set the output\n// gain to 0 anyways (which is required on Edge if we did copy data to output). However, if using a MediaRecorder\n// and a processor (all other browsers), then it would be required to copy the data otherwise the graph would\n// generate no data for the MediaRecorder to consume.\n// if (this.forceScriptProcessor) {\n// // Copy input to output\n// let inputBuffer = e.inputBuffer\n// let outputBuffer = e.outputBuffer\n// // This doesn't work on iOS/Safari. Guessing it doesn't have copyToChannel support, but haven't verified.\n// for (let channel = 0; channel < outputBuffer.numberOfChannels; channel++) {\n//   outputBuffer.copyToChannel(inputBuffer.getChannelData(channel), channel)\n// }\n// Safari and Edge require manual encoding via web worker. Single channel only for now.\n// Example stereo encoderWav: https://github.com/MicrosoftEdge/Demos/blob/master/microphone/scripts/recorderworker.js\nif(!_this.config.usingMediaRecorder){if(_this.state==='recording'){if(_this.config.broadcastAudioProcessEvents){_this.encoderWorker.postMessage(['encode',e.outputBuffer.getChannelData(0)]);}else{_this.encoderWorker.postMessage(['encode',e.inputBuffer.getChannelData(0)]);}}}};this.stopRecording=function(){if(_this.state==='inactive'){return;}if(_this.config.usingMediaRecorder){_this.state='inactive';_this.mediaRecorder.stop();}else{_this.state='inactive';_this.encoderWorker.postMessage(['dump',_this.audioCtx.sampleRate]);clearInterval(_this.slicing);// TODO: There should be a more robust way to handle this\n// Without something like this, I think  the last recorded sample could be lost due to timing\n// setTimeout(() => {\n//   this.state = 'inactive'\n//   this.encoderWorker.postMessage(['dump', this.audioCtx.sampleRate])\n// }, 100)\n}};this._onDataAvailable=function(evt){// console.log('state', this.mediaRecorder.state)\n// console.log('evt.data', evt.data)\n_this.chunks.push(evt.data);_this.chunkType=evt.data.type;if(_this.state!=='inactive'){return;}var blob=new Blob(_this.chunks,{type:_this.chunkType});var blobUrl=URL.createObjectURL(blob);var recording={ts:new Date().getTime(),blobUrl:blobUrl,mimeType:blob.type,size:blob.size};_this.chunks=[];_this.chunkType=null;if(_this.destinationNode){_this.destinationNode.disconnect();_this.destinationNode=null;}if(_this.outputGainNode){_this.outputGainNode.disconnect();_this.outputGainNode=null;}if(_this.analyserNode){_this.analyserNode.disconnect();_this.analyserNode=null;}if(_this.processorNode){_this.processorNode.disconnect();_this.processorNode=null;}if(_this.encoderWorker){_this.encoderWorker.postMessage(['close']);_this.encoderWorker=null;}if(_this.dynamicsCompressorNode){_this.dynamicsCompressorNode.disconnect();_this.dynamicsCompressorNode=null;}if(_this.micGainNode){_this.micGainNode.disconnect();_this.micGainNode=null;}if(_this.inputStreamNode){_this.inputStreamNode.disconnect();_this.inputStreamNode=null;}if(_this.config.stopTracksAndCloseCtxWhenFinished){// This removes the red bar in iOS/Safari\n_this.micAudioStream.getTracks().forEach(function(track){return track.stop();});_this.micAudioStream=null;_this.audioCtx.close();_this.audioCtx=null;}_this.em.dispatchEvent(new CustomEvent('recording',{detail:{recording:recording}}));};this._onError=function(evt){console.log('error',evt);_this.em.dispatchEvent(new Event('error'));// alert(`error:${evt}`); // for debugging purposes\n};window.AudioContext=window.AudioContext||window.webkitAudioContext;this.em=document.createDocumentFragment();this.state='inactive';this.chunks=[];this.chunkType='';this.encoderMimeType='audio/wav';this.config={broadcastAudioProcessEvents:config.broadcastAudioProcessEvents!==undefined?config.broadcastAudioProcessEvents:false,createAnalyserNode:config.createAnalyserNode!==undefined?config.createAnalyserNode:false,createDynamicsCompressorNode:config.createDynamicsCompressorNode!==undefined?config.createDynamicsCompressorNode:false,forceScriptProcessor:config.forceScriptProcessor!==undefined?config.forceScriptProcessor:false,manualEncoderId:config.manualEncoderId!==undefined?config.manualEncoderId:'wav',micGain:config.micGain!==undefined?config.micGain:1.0,processorBufferSize:config.processorBufferSize!==undefined?config.processorBufferSize:2048,stopTracksAndCloseCtxWhenFinished:config.stopTracksAndCloseCtxWhenFinished!==undefined?config.stopTracksAndCloseCtxWhenFinished:true,usingMediaRecorder:config.usingMediaRecorder!==undefined?config.usingMediaRecorder:typeof window.MediaRecorder!=='undefined',enableEchoCancellation:config.enableEchoCancellation!==undefined?config.enableEchoCancellation:true,sampleRate:config.sampleRate!==undefined?config.sampleRate:44100,onRecording:config.onRecording,onAudioPress:config.onAudioPress};if(config.onRecording){this.recordingFn=function(evt){return config.onRecording(evt);};this.em.addEventListener('recording',this.recordingFn);}if(config.onAudioProcesss){this.onAudioProcessFn=function(evt){return config.onAudioProcesss(evt);};this.em.addEventListener('onaudioprocess',this.onAudioProcessFn);}};export{RecorderService as default};","map":{"version":3,"sources":["/Users/arcsec/Documents/Virufy/virufy-demo.github.io/src/helper/audio/RecorderService.js"],"names":["EncoderWav","EncoderMp3","EncoderFlac","RecorderService","config","cleanup","onRecording","em","removeEventListener","recordingFn","onAudioProcesss","onAudioProcessFn","createWorker","fn","js","toString","replace","blob","Blob","Worker","URL","createObjectURL","startRecording","timeslice","state","navigator","mediaDevices","getUserMedia","audioCtx","AudioContext","sampleRate","micGainNode","createGain","outputGainNode","createDynamicsCompressorNode","dynamicsCompressorNode","createDynamicsCompressor","createAnalyserNode","analyserNode","createAnalyser","forceScriptProcessor","broadcastAudioProcessEvents","usingMediaRecorder","processorNode","createScriptProcessor","processorBufferSize","createMediaStreamDestination","destinationNode","destination","manualEncoderId","encoderWorker","baseUrl","process","env","PUBLIC_URL","postMessage","encoderMimeType","addEventListener","e","event","Event","data","type","_onDataAvailable","userMediaConstraints","audio","echoCancellation","enableEchoCancellation","deviceId","then","stream","_startRecordingWithStream","catch","error","console","log","setMicGain","newGain","micGain","gain","setValueAtTime","currentTime","micAudioStream","inputStreamNode","createMediaStreamSource","context","onGraphSetupWithInputStream","connect","nextNode","onaudioprocess","_onAudioProcess","mediaRecorder","MediaRecorder","mimeType","evt","_onError","start","slicing","setInterval","anon","dispatchEvent","CustomEvent","detail","inputBuffer","outputBuffer","getChannelData","stopRecording","stop","clearInterval","chunks","push","chunkType","blobUrl","recording","ts","Date","getTime","size","disconnect","stopTracksAndCloseCtxWhenFinished","getTracks","forEach","track","close","window","webkitAudioContext","document","createDocumentFragment","undefined","onAudioPress"],"mappings":"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","sourcesContent":["/* eslint-disable max-len */\n/* eslint-disable consistent-return */\n/* eslint-disable no-underscore-dangle */\n// Vendor Library https://github.com/mogwai/pwa-audio-recorder/tree/master\n\nimport EncoderWav from './encoder-wav-worker';\nimport EncoderMp3 from './encoder-mp3-worker';\nimport EncoderFlac from './encoder-flac-worker';\n// import EncoderOgg from './encoder-ogg-worker';\n\nexport default class RecorderService {\n  constructor(config) {\n    window.AudioContext = window.AudioContext || window.webkitAudioContext;\n\n    this.em = document.createDocumentFragment();\n\n    this.state = 'inactive';\n\n    this.chunks = [];\n    this.chunkType = '';\n\n    this.encoderMimeType = 'audio/wav';\n\n    this.config = {\n      broadcastAudioProcessEvents: config.broadcastAudioProcessEvents !== undefined ? config.broadcastAudioProcessEvents : false,\n      createAnalyserNode: config.createAnalyserNode !== undefined ? config.createAnalyserNode : false,\n      createDynamicsCompressorNode: config.createDynamicsCompressorNode !== undefined ? config.createDynamicsCompressorNode : false,\n      forceScriptProcessor: config.forceScriptProcessor !== undefined ? config.forceScriptProcessor : false,\n      manualEncoderId: config.manualEncoderId !== undefined ? config.manualEncoderId : 'wav',\n      micGain: config.micGain !== undefined ? config.micGain : 1.0,\n      processorBufferSize: config.processorBufferSize !== undefined ? config.processorBufferSize : 2048,\n      stopTracksAndCloseCtxWhenFinished: config.stopTracksAndCloseCtxWhenFinished !== undefined ? config.stopTracksAndCloseCtxWhenFinished : true,\n      usingMediaRecorder: config.usingMediaRecorder !== undefined ? config.usingMediaRecorder : typeof window.MediaRecorder !== 'undefined',\n      enableEchoCancellation: config.enableEchoCancellation !== undefined ? config.enableEchoCancellation : true,\n      sampleRate: config.sampleRate !== undefined ? config.sampleRate : 44100,\n      onRecording: config.onRecording,\n      onAudioPress: config.onAudioPress,\n    };\n\n    if (config.onRecording) {\n      this.recordingFn = evt => config.onRecording(evt);\n      this.em.addEventListener('recording', this.recordingFn);\n    }\n    if (config.onAudioProcesss) {\n      this.onAudioProcessFn = evt => config.onAudioProcesss(evt);\n      this.em.addEventListener('onaudioprocess', this.onAudioProcessFn);\n    }\n  }\n\n  cleanup = () => {\n    if (this.config.onRecording) {\n      this.em.removeEventListener('recording', this.recordingFn);\n    }\n    if (this.config.onAudioProcesss) {\n      this.em.removeEventListener('onaudioprocess', this.onAudioProcessFn);\n    }\n  };\n\n  createWorker = fn => {\n    const js = fn\n      .toString()\n      .replace(/^function\\s*\\(\\)\\s*{/, '')\n      .replace(/}$/, '');\n    const blob = new Blob([js]);\n    return new Worker(URL.createObjectURL(blob));\n  };\n\n  startRecording = timeslice => {\n    if (this.state !== 'inactive') {\n      return;\n    }\n\n    // This is the case on ios/chrome, when clicking links from within ios/slack (sometimes), etc.\n    if (\n      !navigator\n      || !navigator.mediaDevices\n      || !navigator.mediaDevices.getUserMedia\n    ) {\n      // alert('Missing support for navigator.mediaDevices.getUserMedia'); // temp: helps when testing for strange issues on ios/safari\n      return;\n    }\n\n    this.audioCtx = new AudioContext({\n      sampleRate: this.config.sampleRate,\n    });\n    this.micGainNode = this.audioCtx.createGain();\n    this.outputGainNode = this.audioCtx.createGain();\n\n    if (this.config.createDynamicsCompressorNode) {\n      this.dynamicsCompressorNode = this.audioCtx.createDynamicsCompressor();\n    }\n\n    if (this.config.createAnalyserNode) {\n      this.analyserNode = this.audioCtx.createAnalyser();\n    }\n\n    // If not using MediaRecorder(i.e. safari and edge), then a script processor is required. It's optional\n    // on browsers using MediaRecorder and is only useful if wanting to do custom analysis or manipulation of\n    // recorded audio data.\n    if (\n      this.config.forceScriptProcessor\n      || this.config.broadcastAudioProcessEvents\n      || !this.config.usingMediaRecorder\n    ) {\n      this.processorNode = this.audioCtx.createScriptProcessor(\n        this.config.processorBufferSize,\n        1,\n        1,\n      ); // TODO: Get the number of channels from mic\n    }\n\n    // Create stream destination on chrome/firefox because, AFAICT, we have no other way of feeding audio graph output\n    // in to MediaRecorderSafari/Edge don't have this method as of 2018-04.\n    if (this.audioCtx.createMediaStreamDestination) {\n      this.destinationNode = this.audioCtx.createMediaStreamDestination();\n    } else {\n      this.destinationNode = this.audioCtx.destination;\n    }\n\n    // Create web worker for doing the encoding\n    if (!this.config.usingMediaRecorder) {\n      if (this.config.manualEncoderId === 'mp3') {\n        this.encoderWorker = this.createWorker(EncoderMp3);\n        const baseUrl = process.env.PUBLIC_URL || 'https://virufy.org/demo';\n        this.encoderWorker.postMessage([\n          'init',\n          { baseUrl, sampleRate: this.audioCtx.sampleRate },\n        ]);\n        this.encoderMimeType = 'audio/mpeg';\n      } else if (this.config.manualEncoderId === 'flac') {\n        this.encoderWorker = this.createWorker(EncoderFlac);\n        this.encoderWorker.postMessage([\n          'init',\n          { sampleRate: this.audioCtx.sampleRate },\n        ]);\n        this.encoderMimeType = 'audio/flac';\n      } else {\n        this.encoderWorker = this.createWorker(EncoderWav);\n        this.encoderMimeType = 'audio/wav';\n      }\n      this.encoderWorker.addEventListener('message', e => {\n        const event = new Event('dataavailable');\n        if (this.config.manualEncoderId === 'ogg' || this.config.manualEncoderId === 'flac') {\n          event.data = e.data;\n        } else {\n          event.data = new Blob(e.data, { type: this.encoderMimeType });\n        }\n        this._onDataAvailable(event);\n      });\n    }\n\n    // Setup media constraints\n    const userMediaConstraints = {\n      audio: {\n        echoCancellation: this.config.enableEchoCancellation,\n      },\n    };\n    if (this.config.deviceId) {\n      userMediaConstraints.audio.deviceId = this.config.deviceId;\n    }\n\n    // This will prompt user for permission if needed\n    return navigator.mediaDevices\n      .getUserMedia(userMediaConstraints)\n      .then(stream => {\n        this._startRecordingWithStream(stream, timeslice);\n      })\n      .catch(error => {\n        // alert(`Error with getUserMedia: ${error.message}`); // temp: helps when testing for strange issues on ios/safari\n        console.log(error);\n      });\n  };\n\n  setMicGain = newGain => {\n    this.config.micGain = newGain;\n    if (this.audioCtx && this.micGainNode) {\n      this.micGainNode.gain.setValueAtTime(newGain, this.audioCtx.currentTime);\n    }\n  };\n\n  _startRecordingWithStream = (stream, timeslice) => {\n    this.micAudioStream = stream;\n\n    this.inputStreamNode = this.audioCtx.createMediaStreamSource(\n      this.micAudioStream,\n    );\n    this.audioCtx = this.inputStreamNode.context;\n\n    // Kind-of a hack to allow hooking in to audioGraph inputStreamNode\n    if (this.onGraphSetupWithInputStream) {\n      this.onGraphSetupWithInputStream(this.inputStreamNode);\n    }\n\n    this.inputStreamNode.connect(this.micGainNode);\n    this.micGainNode.gain.setValueAtTime(\n      this.config.micGain,\n      this.audioCtx.currentTime,\n    );\n\n    let nextNode = this.micGainNode;\n    if (this.dynamicsCompressorNode) {\n      this.micGainNode.connect(this.dynamicsCompressorNode);\n      nextNode = this.dynamicsCompressorNode;\n    }\n\n    this.state = 'recording';\n\n    if (this.processorNode) {\n      nextNode.connect(this.processorNode);\n      this.processorNode.connect(this.outputGainNode);\n      this.processorNode.onaudioprocess = e => this._onAudioProcess(e);\n    } else {\n      nextNode.connect(this.outputGainNode);\n    }\n\n    if (this.analyserNode) {\n      // TODO: If we want the analyser node to receive the processorNode's output, this needs to be changed _and_\n      //       processor node needs to be modified to copy input to output. It currently doesn't because it's not\n      //       needed when doing manual encoding.\n      // this.processorNode.connect(this.analyserNode)\n      nextNode.connect(this.analyserNode);\n    }\n\n    this.outputGainNode.connect(this.destinationNode);\n\n    if (this.config.usingMediaRecorder) {\n      this.mediaRecorder = new MediaRecorder(this.destinationNode.stream, { mimeType: this.encoderMimeType || 'audio/wav' });\n      this.mediaRecorder.addEventListener('dataavailable', evt => this._onDataAvailable(evt));\n      this.mediaRecorder.addEventListener('error', evt => this._onError(evt));\n\n      this.mediaRecorder.start(timeslice);\n    } else {\n      // Output gain to zero to prevent feedback. Seems to matter only on Edge, though seems like should matter\n      // on iOS too.  Matters on chrome when connecting graph to directly to audioCtx.destination, but we are\n      // not able to do that when using MediaRecorder.\n      this.outputGainNode.gain.setValueAtTime(0, this.audioCtx.currentTime);\n      // this.outputGainNode.gain.value = 0\n\n      // Todo: Note that time slicing with manual wav encoderWav won't work. To allow it would require rewriting the encoderWav\n      // to assemble all chunks at end instead of adding header to each chunk.\n      if (timeslice) {\n        console.log(\n          'Time slicing without MediaRecorder is not yet supported. The resulting recording will not be playable.',\n        );\n        this.slicing = setInterval(function anon() {\n          if (this.state === 'recording') {\n            this.encoderWorker.postMessage(['dump', this.context.sampleRate]);\n          }\n        }, timeslice);\n      }\n    }\n  };\n\n  _onAudioProcess = e => {\n    // console.log('onaudioprocess', e)\n    // let inputBuffer = e.inputBuffer\n    // let outputBuffer = e.outputBuffer\n    // console.log(this.micAudioStream)\n    // console.log(this.audioCtx)\n    // console.log(this.micAudioStream.getTracks().forEach((track) => console.log(track)))\n\n    // this.onAudioEm.dispatch(new Event('onaudioprocess', {inputBuffer:inputBuffer,outputBuffer:outputBuffer}))\n\n    if (this.config.broadcastAudioProcessEvents) {\n      this.em.dispatchEvent(\n        new CustomEvent('onaudioprocess', {\n          detail: {\n            inputBuffer: e.inputBuffer,\n            outputBuffer: e.outputBuffer,\n          },\n        }),\n      );\n    }\n\n    // // Example handling:\n    // let inputBuffer = e.inputBuffer\n    // let outputBuffer = e.outputBuffer\n    // // Each channel (usually only one)\n    // for (let channel = 0; channel < outputBuffer.numberOfChannels; channel++) {\n    //   let inputData = inputBuffer.getChannelData(channel)\n    //   let outputData = outputBuffer.getChannelData(channel)\n    //\n    //   // Each sample\n    //   for (let sample = 0; sample < inputBuffer.length; sample++) {\n    //     // Make output equal to the same as the input (thus processor is doing nothing at this time)\n    //     outputData[sample] = inputData[sample]\n    //   }\n    // }\n\n    // When manually encoding (safari/edge), there's no reason to copy data to output buffer.  We set the output\n    // gain to 0 anyways (which is required on Edge if we did copy data to output). However, if using a MediaRecorder\n    // and a processor (all other browsers), then it would be required to copy the data otherwise the graph would\n    // generate no data for the MediaRecorder to consume.\n    // if (this.forceScriptProcessor) {\n\n    // // Copy input to output\n    // let inputBuffer = e.inputBuffer\n    // let outputBuffer = e.outputBuffer\n    // // This doesn't work on iOS/Safari. Guessing it doesn't have copyToChannel support, but haven't verified.\n    // for (let channel = 0; channel < outputBuffer.numberOfChannels; channel++) {\n    //   outputBuffer.copyToChannel(inputBuffer.getChannelData(channel), channel)\n    // }\n\n    // Safari and Edge require manual encoding via web worker. Single channel only for now.\n    // Example stereo encoderWav: https://github.com/MicrosoftEdge/Demos/blob/master/microphone/scripts/recorderworker.js\n    if (!this.config.usingMediaRecorder) {\n      if (this.state === 'recording') {\n        if (this.config.broadcastAudioProcessEvents) {\n          this.encoderWorker.postMessage([\n            'encode',\n            e.outputBuffer.getChannelData(0),\n          ]);\n        } else {\n          this.encoderWorker.postMessage([\n            'encode',\n            e.inputBuffer.getChannelData(0),\n          ]);\n        }\n      }\n    }\n  };\n\n  stopRecording = () => {\n    if (this.state === 'inactive') {\n      return;\n    }\n    if (this.config.usingMediaRecorder) {\n      this.state = 'inactive';\n      this.mediaRecorder.stop();\n    } else {\n      this.state = 'inactive';\n      this.encoderWorker.postMessage(['dump', this.audioCtx.sampleRate]);\n      clearInterval(this.slicing);\n\n      // TODO: There should be a more robust way to handle this\n      // Without something like this, I think  the last recorded sample could be lost due to timing\n      // setTimeout(() => {\n      //   this.state = 'inactive'\n      //   this.encoderWorker.postMessage(['dump', this.audioCtx.sampleRate])\n      // }, 100)\n    }\n  };\n\n  _onDataAvailable = evt => {\n    // console.log('state', this.mediaRecorder.state)\n    // console.log('evt.data', evt.data)\n\n    this.chunks.push(evt.data);\n    this.chunkType = evt.data.type;\n\n    if (this.state !== 'inactive') {\n      return;\n    }\n\n    const blob = new Blob(this.chunks, { type: this.chunkType });\n    const blobUrl = URL.createObjectURL(blob);\n    const recording = {\n      ts: new Date().getTime(),\n      blobUrl,\n      mimeType: blob.type,\n      size: blob.size,\n    };\n\n    this.chunks = [];\n    this.chunkType = null;\n\n    if (this.destinationNode) {\n      this.destinationNode.disconnect();\n      this.destinationNode = null;\n    }\n    if (this.outputGainNode) {\n      this.outputGainNode.disconnect();\n      this.outputGainNode = null;\n    }\n    if (this.analyserNode) {\n      this.analyserNode.disconnect();\n      this.analyserNode = null;\n    }\n    if (this.processorNode) {\n      this.processorNode.disconnect();\n      this.processorNode = null;\n    }\n    if (this.encoderWorker) {\n      this.encoderWorker.postMessage(['close']);\n      this.encoderWorker = null;\n    }\n    if (this.dynamicsCompressorNode) {\n      this.dynamicsCompressorNode.disconnect();\n      this.dynamicsCompressorNode = null;\n    }\n    if (this.micGainNode) {\n      this.micGainNode.disconnect();\n      this.micGainNode = null;\n    }\n    if (this.inputStreamNode) {\n      this.inputStreamNode.disconnect();\n      this.inputStreamNode = null;\n    }\n\n    if (this.config.stopTracksAndCloseCtxWhenFinished) {\n      // This removes the red bar in iOS/Safari\n      this.micAudioStream.getTracks().forEach(track => track.stop());\n      this.micAudioStream = null;\n\n      this.audioCtx.close();\n      this.audioCtx = null;\n    }\n\n    this.em.dispatchEvent(\n      new CustomEvent('recording', { detail: { recording } }),\n    );\n  };\n\n  _onError = evt => {\n    console.log('error', evt);\n    this.em.dispatchEvent(new Event('error'));\n    // alert(`error:${evt}`); // for debugging purposes\n  };\n}\n"]},"metadata":{},"sourceType":"module"}