{"ast":null,"code":"import _classCallCheck from\"/home/amil/virufy-demo.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";/* eslint-disable max-len */ /* eslint-disable consistent-return */ /* eslint-disable no-underscore-dangle */ // Vendor Library https://github.com/mogwai/pwa-audio-recorder/tree/master\nimport EncoderWav from'./encoder-wav-worker';import EncoderMp3 from'./encoder-mp3-worker';import EncoderFlac from'./encoder-flac-worker';// import EncoderOgg from './encoder-ogg-worker';\nvar RecorderService=function RecorderService(config){var _this=this;_classCallCheck(this,RecorderService);this.cleanup=function(){if(_this.config.onRecording){_this.em.removeEventListener('recording',_this.recordingFn);}if(_this.config.onAudioProcesss){_this.em.removeEventListener('onaudioprocess',_this.onAudioProcessFn);}};this.createWorker=function(fn){var js=fn.toString().replace(/^function\\s*\\(\\)\\s*{/,'').replace(/}$/,'');var blob=new Blob([js]);return new Worker(URL.createObjectURL(blob));};this.startRecording=function(timeslice){if(_this.state!=='inactive'){return;}// This is the case on ios/chrome, when clicking links from within ios/slack (sometimes), etc.\nif(!navigator||!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia){// alert('Missing support for navigator.mediaDevices.getUserMedia'); // temp: helps when testing for strange issues on ios/safari\nreturn;}_this.audioCtx=new AudioContext({sampleRate:_this.config.sampleRate});_this.micGainNode=_this.audioCtx.createGain();_this.outputGainNode=_this.audioCtx.createGain();if(_this.config.createDynamicsCompressorNode){_this.dynamicsCompressorNode=_this.audioCtx.createDynamicsCompressor();}if(_this.config.createAnalyserNode){_this.analyserNode=_this.audioCtx.createAnalyser();}// If not using MediaRecorder(i.e. safari and edge), then a script processor is required. It's optional\n// on browsers using MediaRecorder and is only useful if wanting to do custom analysis or manipulation of\n// recorded audio data.\nif(_this.config.forceScriptProcessor||_this.config.broadcastAudioProcessEvents||!_this.config.usingMediaRecorder){_this.processorNode=_this.audioCtx.createScriptProcessor(_this.config.processorBufferSize,1,1);// TODO: Get the number of channels from mic\n}// Create stream destination on chrome/firefox because, AFAICT, we have no other way of feeding audio graph output\n// in to MediaRecorderSafari/Edge don't have this method as of 2018-04.\nif(_this.audioCtx.createMediaStreamDestination){_this.destinationNode=_this.audioCtx.createMediaStreamDestination();}else{_this.destinationNode=_this.audioCtx.destination;}// Create web worker for doing the encoding\nif(!_this.config.usingMediaRecorder){if(_this.config.manualEncoderId==='mp3'){_this.encoderWorker=_this.createWorker(EncoderMp3);var baseUrl=process.env.PUBLIC_URL||'https://virufy.org/demo';_this.encoderWorker.postMessage(['init',{baseUrl:baseUrl,sampleRate:_this.audioCtx.sampleRate}]);_this.encoderMimeType='audio/mpeg';}else if(_this.config.manualEncoderId==='flac'){_this.encoderWorker=_this.createWorker(EncoderFlac);_this.encoderWorker.postMessage(['init',{sampleRate:_this.audioCtx.sampleRate}]);_this.encoderMimeType='audio/flac';}else{_this.encoderWorker=_this.createWorker(EncoderWav);_this.encoderMimeType='audio/wav';}_this.encoderWorker.addEventListener('message',function(e){var event=new Event('dataavailable');if(_this.config.manualEncoderId==='ogg'||_this.config.manualEncoderId==='flac'){event.data=e.data;}else{event.data=new Blob(e.data,{type:_this.encoderMimeType});}_this._onDataAvailable(event);});}// Setup media constraints\nvar userMediaConstraints={audio:{echoCancellation:_this.config.enableEchoCancellation}};if(_this.config.deviceId){userMediaConstraints.audio.deviceId=_this.config.deviceId;}// This will prompt user for permission if needed\nreturn navigator.mediaDevices.getUserMedia(userMediaConstraints).then(function(stream){_this._startRecordingWithStream(stream,timeslice);}).catch(function(error){// alert(`Error with getUserMedia: ${error.message}`); // temp: helps when testing for strange issues on ios/safari\nconsole.log(error);});};this.setMicGain=function(newGain){_this.config.micGain=newGain;if(_this.audioCtx&&_this.micGainNode){_this.micGainNode.gain.setValueAtTime(newGain,_this.audioCtx.currentTime);}};this._startRecordingWithStream=function(stream,timeslice){_this.micAudioStream=stream;_this.inputStreamNode=_this.audioCtx.createMediaStreamSource(_this.micAudioStream);_this.audioCtx=_this.inputStreamNode.context;// Kind-of a hack to allow hooking in to audioGraph inputStreamNode\nif(_this.onGraphSetupWithInputStream){_this.onGraphSetupWithInputStream(_this.inputStreamNode);}_this.inputStreamNode.connect(_this.micGainNode);_this.micGainNode.gain.setValueAtTime(_this.config.micGain,_this.audioCtx.currentTime);var nextNode=_this.micGainNode;if(_this.dynamicsCompressorNode){_this.micGainNode.connect(_this.dynamicsCompressorNode);nextNode=_this.dynamicsCompressorNode;}_this.state='recording';if(_this.processorNode){nextNode.connect(_this.processorNode);_this.processorNode.connect(_this.outputGainNode);_this.processorNode.onaudioprocess=function(e){return _this._onAudioProcess(e);};}else{nextNode.connect(_this.outputGainNode);}if(_this.analyserNode){// TODO: If we want the analyser node to receive the processorNode's output, this needs to be changed _and_\n//       processor node needs to be modified to copy input to output. It currently doesn't because it's not\n//       needed when doing manual encoding.\n// this.processorNode.connect(this.analyserNode)\nnextNode.connect(_this.analyserNode);}_this.outputGainNode.connect(_this.destinationNode);if(_this.config.usingMediaRecorder){_this.mediaRecorder=new MediaRecorder(_this.destinationNode.stream,{mimeType:_this.encoderMimeType||'audio/wav'});_this.mediaRecorder.addEventListener('dataavailable',function(evt){return _this._onDataAvailable(evt);});_this.mediaRecorder.addEventListener('error',function(evt){return _this._onError(evt);});_this.mediaRecorder.start(timeslice);}else{// Output gain to zero to prevent feedback. Seems to matter only on Edge, though seems like should matter\n// on iOS too.  Matters on chrome when connecting graph to directly to audioCtx.destination, but we are\n// not able to do that when using MediaRecorder.\n_this.outputGainNode.gain.setValueAtTime(0,_this.audioCtx.currentTime);// this.outputGainNode.gain.value = 0\n// Todo: Note that time slicing with manual wav encoderWav won't work. To allow it would require rewriting the encoderWav\n// to assemble all chunks at end instead of adding header to each chunk.\nif(timeslice){console.log('Time slicing without MediaRecorder is not yet supported. The resulting recording will not be playable.');_this.slicing=setInterval(function anon(){if(this.state==='recording'){this.encoderWorker.postMessage(['dump',this.context.sampleRate]);}},timeslice);}}};this._onAudioProcess=function(e){// console.log('onaudioprocess', e)\n// let inputBuffer = e.inputBuffer\n// let outputBuffer = e.outputBuffer\n// console.log(this.micAudioStream)\n// console.log(this.audioCtx)\n// console.log(this.micAudioStream.getTracks().forEach((track) => console.log(track)))\n// this.onAudioEm.dispatch(new Event('onaudioprocess', {inputBuffer:inputBuffer,outputBuffer:outputBuffer}))\nif(_this.config.broadcastAudioProcessEvents){_this.em.dispatchEvent(new CustomEvent('onaudioprocess',{detail:{inputBuffer:e.inputBuffer,outputBuffer:e.outputBuffer}}));}// // Example handling:\n// let inputBuffer = e.inputBuffer\n// let outputBuffer = e.outputBuffer\n// // Each channel (usually only one)\n// for (let channel = 0; channel < outputBuffer.numberOfChannels; channel++) {\n//   let inputData = inputBuffer.getChannelData(channel)\n//   let outputData = outputBuffer.getChannelData(channel)\n//\n//   // Each sample\n//   for (let sample = 0; sample < inputBuffer.length; sample++) {\n//     // Make output equal to the same as the input (thus processor is doing nothing at this time)\n//     outputData[sample] = inputData[sample]\n//   }\n// }\n// When manually encoding (safari/edge), there's no reason to copy data to output buffer.  We set the output\n// gain to 0 anyways (which is required on Edge if we did copy data to output). However, if using a MediaRecorder\n// and a processor (all other browsers), then it would be required to copy the data otherwise the graph would\n// generate no data for the MediaRecorder to consume.\n// if (this.forceScriptProcessor) {\n// // Copy input to output\n// let inputBuffer = e.inputBuffer\n// let outputBuffer = e.outputBuffer\n// // This doesn't work on iOS/Safari. Guessing it doesn't have copyToChannel support, but haven't verified.\n// for (let channel = 0; channel < outputBuffer.numberOfChannels; channel++) {\n//   outputBuffer.copyToChannel(inputBuffer.getChannelData(channel), channel)\n// }\n// Safari and Edge require manual encoding via web worker. Single channel only for now.\n// Example stereo encoderWav: https://github.com/MicrosoftEdge/Demos/blob/master/microphone/scripts/recorderworker.js\nif(!_this.config.usingMediaRecorder){if(_this.state==='recording'){if(_this.config.broadcastAudioProcessEvents){_this.encoderWorker.postMessage(['encode',e.outputBuffer.getChannelData(0)]);}else{_this.encoderWorker.postMessage(['encode',e.inputBuffer.getChannelData(0)]);}}}};this.stopRecording=function(){if(_this.state==='inactive'){return;}if(_this.config.usingMediaRecorder){_this.state='inactive';_this.mediaRecorder.stop();}else{_this.state='inactive';_this.encoderWorker.postMessage(['dump',_this.audioCtx.sampleRate]);clearInterval(_this.slicing);// TODO: There should be a more robust way to handle this\n// Without something like this, I think  the last recorded sample could be lost due to timing\n// setTimeout(() => {\n//   this.state = 'inactive'\n//   this.encoderWorker.postMessage(['dump', this.audioCtx.sampleRate])\n// }, 100)\n}};this._onDataAvailable=function(evt){// console.log('state', this.mediaRecorder.state)\n// console.log('evt.data', evt.data)\n_this.chunks.push(evt.data);_this.chunkType=evt.data.type;if(_this.state!=='inactive'){return;}var blob=new Blob(_this.chunks,{type:_this.chunkType});var blobUrl=URL.createObjectURL(blob);var recording={ts:new Date().getTime(),blobUrl:blobUrl,mimeType:blob.type,size:blob.size};_this.chunks=[];_this.chunkType=null;if(_this.destinationNode){_this.destinationNode.disconnect();_this.destinationNode=null;}if(_this.outputGainNode){_this.outputGainNode.disconnect();_this.outputGainNode=null;}if(_this.analyserNode){_this.analyserNode.disconnect();_this.analyserNode=null;}if(_this.processorNode){_this.processorNode.disconnect();_this.processorNode=null;}if(_this.encoderWorker){_this.encoderWorker.postMessage(['close']);_this.encoderWorker=null;}if(_this.dynamicsCompressorNode){_this.dynamicsCompressorNode.disconnect();_this.dynamicsCompressorNode=null;}if(_this.micGainNode){_this.micGainNode.disconnect();_this.micGainNode=null;}if(_this.inputStreamNode){_this.inputStreamNode.disconnect();_this.inputStreamNode=null;}if(_this.config.stopTracksAndCloseCtxWhenFinished){// This removes the red bar in iOS/Safari\n_this.micAudioStream.getTracks().forEach(function(track){return track.stop();});_this.micAudioStream=null;_this.audioCtx.close();_this.audioCtx=null;}_this.em.dispatchEvent(new CustomEvent('recording',{detail:{recording:recording}}));};this._onError=function(evt){console.log('error',evt);_this.em.dispatchEvent(new Event('error'));// alert(`error:${evt}`); // for debugging purposes\n};window.AudioContext=window.AudioContext||window.webkitAudioContext;this.em=document.createDocumentFragment();this.state='inactive';this.chunks=[];this.chunkType='';this.encoderMimeType='audio/wav';this.config={broadcastAudioProcessEvents:config.broadcastAudioProcessEvents!==undefined?config.broadcastAudioProcessEvents:false,createAnalyserNode:config.createAnalyserNode!==undefined?config.createAnalyserNode:false,createDynamicsCompressorNode:config.createDynamicsCompressorNode!==undefined?config.createDynamicsCompressorNode:false,forceScriptProcessor:config.forceScriptProcessor!==undefined?config.forceScriptProcessor:false,manualEncoderId:config.manualEncoderId!==undefined?config.manualEncoderId:'wav',micGain:config.micGain!==undefined?config.micGain:1.0,processorBufferSize:config.processorBufferSize!==undefined?config.processorBufferSize:2048,stopTracksAndCloseCtxWhenFinished:config.stopTracksAndCloseCtxWhenFinished!==undefined?config.stopTracksAndCloseCtxWhenFinished:true,usingMediaRecorder:config.usingMediaRecorder!==undefined?config.usingMediaRecorder:typeof window.MediaRecorder!=='undefined',enableEchoCancellation:config.enableEchoCancellation!==undefined?config.enableEchoCancellation:true,sampleRate:config.sampleRate!==undefined?config.sampleRate:44100,onRecording:config.onRecording,onAudioPress:config.onAudioPress};if(config.onRecording){this.recordingFn=function(evt){return config.onRecording(evt);};this.em.addEventListener('recording',this.recordingFn);}if(config.onAudioProcesss){this.onAudioProcessFn=function(evt){return config.onAudioProcesss(evt);};this.em.addEventListener('onaudioprocess',this.onAudioProcessFn);}};export{RecorderService as default};","map":null,"metadata":{},"sourceType":"module"}