{"ast":null,"code":"/* eslint-disable max-len */\n\n/* eslint-disable consistent-return */\n\n/* eslint-disable no-underscore-dangle */\n// Vendor Library https://github.com/mogwai/pwa-audio-recorder/tree/master\nimport EncoderWav from './encoder-wav-worker';\nimport EncoderMp3 from './encoder-mp3-worker';\nimport EncoderFlac from './encoder-flac-worker'; // import EncoderOgg from './encoder-ogg-worker';\n\nexport default class RecorderService {\n  constructor(config) {\n    this.cleanup = () => {\n      if (this.config.onRecording) {\n        this.em.removeEventListener('recording', this.recordingFn);\n      }\n\n      if (this.config.onAudioProcesss) {\n        this.em.removeEventListener('onaudioprocess', this.onAudioProcessFn);\n      }\n    };\n\n    this.createWorker = fn => {\n      const js = fn.toString().replace(/^function\\s*\\(\\)\\s*{/, '').replace(/}$/, '');\n      const blob = new Blob([js]);\n      return new Worker(URL.createObjectURL(blob));\n    };\n\n    this.startRecording = timeslice => {\n      if (this.state !== 'inactive') {\n        return;\n      } // This is the case on ios/chrome, when clicking links from within ios/slack (sometimes), etc.\n\n\n      if (!navigator || !navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n        // alert('Missing support for navigator.mediaDevices.getUserMedia'); // temp: helps when testing for strange issues on ios/safari\n        return;\n      }\n\n      this.audioCtx = new AudioContext({\n        sampleRate: this.config.sampleRate\n      });\n      this.micGainNode = this.audioCtx.createGain();\n      this.outputGainNode = this.audioCtx.createGain();\n\n      if (this.config.createDynamicsCompressorNode) {\n        this.dynamicsCompressorNode = this.audioCtx.createDynamicsCompressor();\n      }\n\n      if (this.config.createAnalyserNode) {\n        this.analyserNode = this.audioCtx.createAnalyser();\n      } // If not using MediaRecorder(i.e. safari and edge), then a script processor is required. It's optional\n      // on browsers using MediaRecorder and is only useful if wanting to do custom analysis or manipulation of\n      // recorded audio data.\n\n\n      if (this.config.forceScriptProcessor || this.config.broadcastAudioProcessEvents || !this.config.usingMediaRecorder) {\n        this.processorNode = this.audioCtx.createScriptProcessor(this.config.processorBufferSize, 1, 1); // TODO: Get the number of channels from mic\n      } // Create stream destination on chrome/firefox because, AFAICT, we have no other way of feeding audio graph output\n      // in to MediaRecorderSafari/Edge don't have this method as of 2018-04.\n\n\n      if (this.audioCtx.createMediaStreamDestination) {\n        this.destinationNode = this.audioCtx.createMediaStreamDestination();\n      } else {\n        this.destinationNode = this.audioCtx.destination;\n      } // Create web worker for doing the encoding\n\n\n      if (!this.config.usingMediaRecorder) {\n        if (this.config.manualEncoderId === 'mp3') {\n          this.encoderWorker = this.createWorker(EncoderMp3);\n          const baseUrl = process.env.PUBLIC_URL || 'https://virufy.org/demo';\n          this.encoderWorker.postMessage(['init', {\n            baseUrl,\n            sampleRate: this.audioCtx.sampleRate\n          }]);\n          this.encoderMimeType = 'audio/mpeg';\n        } else if (this.config.manualEncoderId === 'flac') {\n          this.encoderWorker = this.createWorker(EncoderFlac);\n          this.encoderWorker.postMessage(['init', {\n            sampleRate: this.audioCtx.sampleRate\n          }]);\n          this.encoderMimeType = 'audio/flac';\n        } else {\n          this.encoderWorker = this.createWorker(EncoderWav);\n          this.encoderMimeType = 'audio/wav';\n        }\n\n        this.encoderWorker.addEventListener('message', e => {\n          const event = new Event('dataavailable');\n\n          if (this.config.manualEncoderId === 'ogg' || this.config.manualEncoderId === 'flac') {\n            event.data = e.data;\n          } else {\n            event.data = new Blob(e.data, {\n              type: this.encoderMimeType\n            });\n          }\n\n          this._onDataAvailable(event);\n        });\n      } // Setup media constraints\n\n\n      const userMediaConstraints = {\n        audio: {\n          echoCancellation: this.config.enableEchoCancellation\n        }\n      };\n\n      if (this.config.deviceId) {\n        userMediaConstraints.audio.deviceId = this.config.deviceId;\n      } // This will prompt user for permission if needed\n\n\n      return navigator.mediaDevices.getUserMedia(userMediaConstraints).then(stream => {\n        this._startRecordingWithStream(stream, timeslice);\n      }).catch(error => {\n        // alert(`Error with getUserMedia: ${error.message}`); // temp: helps when testing for strange issues on ios/safari\n        console.log(error);\n      });\n    };\n\n    this.setMicGain = newGain => {\n      this.config.micGain = newGain;\n\n      if (this.audioCtx && this.micGainNode) {\n        this.micGainNode.gain.setValueAtTime(newGain, this.audioCtx.currentTime);\n      }\n    };\n\n    this._startRecordingWithStream = (stream, timeslice) => {\n      this.micAudioStream = stream;\n      this.inputStreamNode = this.audioCtx.createMediaStreamSource(this.micAudioStream);\n      this.audioCtx = this.inputStreamNode.context; // Kind-of a hack to allow hooking in to audioGraph inputStreamNode\n\n      if (this.onGraphSetupWithInputStream) {\n        this.onGraphSetupWithInputStream(this.inputStreamNode);\n      }\n\n      this.inputStreamNode.connect(this.micGainNode);\n      this.micGainNode.gain.setValueAtTime(this.config.micGain, this.audioCtx.currentTime);\n      let nextNode = this.micGainNode;\n\n      if (this.dynamicsCompressorNode) {\n        this.micGainNode.connect(this.dynamicsCompressorNode);\n        nextNode = this.dynamicsCompressorNode;\n      }\n\n      this.state = 'recording';\n\n      if (this.processorNode) {\n        nextNode.connect(this.processorNode);\n        this.processorNode.connect(this.outputGainNode);\n\n        this.processorNode.onaudioprocess = e => this._onAudioProcess(e);\n      } else {\n        nextNode.connect(this.outputGainNode);\n      }\n\n      if (this.analyserNode) {\n        // TODO: If we want the analyser node to receive the processorNode's output, this needs to be changed _and_\n        //       processor node needs to be modified to copy input to output. It currently doesn't because it's not\n        //       needed when doing manual encoding.\n        // this.processorNode.connect(this.analyserNode)\n        nextNode.connect(this.analyserNode);\n      }\n\n      this.outputGainNode.connect(this.destinationNode);\n\n      if (this.config.usingMediaRecorder) {\n        this.mediaRecorder = new MediaRecorder(this.destinationNode.stream, {\n          mimeType: this.encoderMimeType || 'audio/wav'\n        });\n        this.mediaRecorder.addEventListener('dataavailable', evt => this._onDataAvailable(evt));\n        this.mediaRecorder.addEventListener('error', evt => this._onError(evt));\n        this.mediaRecorder.start(timeslice);\n      } else {\n        // Output gain to zero to prevent feedback. Seems to matter only on Edge, though seems like should matter\n        // on iOS too.  Matters on chrome when connecting graph to directly to audioCtx.destination, but we are\n        // not able to do that when using MediaRecorder.\n        this.outputGainNode.gain.setValueAtTime(0, this.audioCtx.currentTime); // this.outputGainNode.gain.value = 0\n        // Todo: Note that time slicing with manual wav encoderWav won't work. To allow it would require rewriting the encoderWav\n        // to assemble all chunks at end instead of adding header to each chunk.\n\n        if (timeslice) {\n          console.log('Time slicing without MediaRecorder is not yet supported. The resulting recording will not be playable.');\n          this.slicing = setInterval(function anon() {\n            if (this.state === 'recording') {\n              this.encoderWorker.postMessage(['dump', this.context.sampleRate]);\n            }\n          }, timeslice);\n        }\n      }\n    };\n\n    this._onAudioProcess = e => {\n      // console.log('onaudioprocess', e)\n      // let inputBuffer = e.inputBuffer\n      // let outputBuffer = e.outputBuffer\n      // console.log(this.micAudioStream)\n      // console.log(this.audioCtx)\n      // console.log(this.micAudioStream.getTracks().forEach((track) => console.log(track)))\n      // this.onAudioEm.dispatch(new Event('onaudioprocess', {inputBuffer:inputBuffer,outputBuffer:outputBuffer}))\n      if (this.config.broadcastAudioProcessEvents) {\n        this.em.dispatchEvent(new CustomEvent('onaudioprocess', {\n          detail: {\n            inputBuffer: e.inputBuffer,\n            outputBuffer: e.outputBuffer\n          }\n        }));\n      } // // Example handling:\n      // let inputBuffer = e.inputBuffer\n      // let outputBuffer = e.outputBuffer\n      // // Each channel (usually only one)\n      // for (let channel = 0; channel < outputBuffer.numberOfChannels; channel++) {\n      //   let inputData = inputBuffer.getChannelData(channel)\n      //   let outputData = outputBuffer.getChannelData(channel)\n      //\n      //   // Each sample\n      //   for (let sample = 0; sample < inputBuffer.length; sample++) {\n      //     // Make output equal to the same as the input (thus processor is doing nothing at this time)\n      //     outputData[sample] = inputData[sample]\n      //   }\n      // }\n      // When manually encoding (safari/edge), there's no reason to copy data to output buffer.  We set the output\n      // gain to 0 anyways (which is required on Edge if we did copy data to output). However, if using a MediaRecorder\n      // and a processor (all other browsers), then it would be required to copy the data otherwise the graph would\n      // generate no data for the MediaRecorder to consume.\n      // if (this.forceScriptProcessor) {\n      // // Copy input to output\n      // let inputBuffer = e.inputBuffer\n      // let outputBuffer = e.outputBuffer\n      // // This doesn't work on iOS/Safari. Guessing it doesn't have copyToChannel support, but haven't verified.\n      // for (let channel = 0; channel < outputBuffer.numberOfChannels; channel++) {\n      //   outputBuffer.copyToChannel(inputBuffer.getChannelData(channel), channel)\n      // }\n      // Safari and Edge require manual encoding via web worker. Single channel only for now.\n      // Example stereo encoderWav: https://github.com/MicrosoftEdge/Demos/blob/master/microphone/scripts/recorderworker.js\n\n\n      if (!this.config.usingMediaRecorder) {\n        if (this.state === 'recording') {\n          if (this.config.broadcastAudioProcessEvents) {\n            this.encoderWorker.postMessage(['encode', e.outputBuffer.getChannelData(0)]);\n          } else {\n            this.encoderWorker.postMessage(['encode', e.inputBuffer.getChannelData(0)]);\n          }\n        }\n      }\n    };\n\n    this.stopRecording = () => {\n      if (this.state === 'inactive') {\n        return;\n      }\n\n      if (this.config.usingMediaRecorder) {\n        this.state = 'inactive';\n        this.mediaRecorder.stop();\n      } else {\n        this.state = 'inactive';\n        this.encoderWorker.postMessage(['dump', this.audioCtx.sampleRate]);\n        clearInterval(this.slicing); // TODO: There should be a more robust way to handle this\n        // Without something like this, I think  the last recorded sample could be lost due to timing\n        // setTimeout(() => {\n        //   this.state = 'inactive'\n        //   this.encoderWorker.postMessage(['dump', this.audioCtx.sampleRate])\n        // }, 100)\n      }\n    };\n\n    this._onDataAvailable = evt => {\n      // console.log('state', this.mediaRecorder.state)\n      // console.log('evt.data', evt.data)\n      this.chunks.push(evt.data);\n      this.chunkType = evt.data.type;\n\n      if (this.state !== 'inactive') {\n        return;\n      }\n\n      const blob = new Blob(this.chunks, {\n        type: this.chunkType\n      });\n      const blobUrl = URL.createObjectURL(blob);\n      const recording = {\n        ts: new Date().getTime(),\n        blobUrl,\n        mimeType: blob.type,\n        size: blob.size\n      };\n      this.chunks = [];\n      this.chunkType = null;\n\n      if (this.destinationNode) {\n        this.destinationNode.disconnect();\n        this.destinationNode = null;\n      }\n\n      if (this.outputGainNode) {\n        this.outputGainNode.disconnect();\n        this.outputGainNode = null;\n      }\n\n      if (this.analyserNode) {\n        this.analyserNode.disconnect();\n        this.analyserNode = null;\n      }\n\n      if (this.processorNode) {\n        this.processorNode.disconnect();\n        this.processorNode = null;\n      }\n\n      if (this.encoderWorker) {\n        this.encoderWorker.postMessage(['close']);\n        this.encoderWorker = null;\n      }\n\n      if (this.dynamicsCompressorNode) {\n        this.dynamicsCompressorNode.disconnect();\n        this.dynamicsCompressorNode = null;\n      }\n\n      if (this.micGainNode) {\n        this.micGainNode.disconnect();\n        this.micGainNode = null;\n      }\n\n      if (this.inputStreamNode) {\n        this.inputStreamNode.disconnect();\n        this.inputStreamNode = null;\n      }\n\n      if (this.config.stopTracksAndCloseCtxWhenFinished) {\n        // This removes the red bar in iOS/Safari\n        this.micAudioStream.getTracks().forEach(track => track.stop());\n        this.micAudioStream = null;\n        this.audioCtx.close();\n        this.audioCtx = null;\n      }\n\n      this.em.dispatchEvent(new CustomEvent('recording', {\n        detail: {\n          recording\n        }\n      }));\n    };\n\n    this._onError = evt => {\n      console.log('error', evt);\n      this.em.dispatchEvent(new Event('error')); // alert(`error:${evt}`); // for debugging purposes\n    };\n\n    window.AudioContext = window.AudioContext || window.webkitAudioContext;\n    this.em = document.createDocumentFragment();\n    this.state = 'inactive';\n    this.chunks = [];\n    this.chunkType = '';\n    this.encoderMimeType = 'audio/wav';\n    this.config = {\n      broadcastAudioProcessEvents: config.broadcastAudioProcessEvents !== undefined ? config.broadcastAudioProcessEvents : false,\n      createAnalyserNode: config.createAnalyserNode !== undefined ? config.createAnalyserNode : false,\n      createDynamicsCompressorNode: config.createDynamicsCompressorNode !== undefined ? config.createDynamicsCompressorNode : false,\n      forceScriptProcessor: config.forceScriptProcessor !== undefined ? config.forceScriptProcessor : false,\n      manualEncoderId: config.manualEncoderId !== undefined ? config.manualEncoderId : 'wav',\n      micGain: config.micGain !== undefined ? config.micGain : 1.0,\n      processorBufferSize: config.processorBufferSize !== undefined ? config.processorBufferSize : 2048,\n      stopTracksAndCloseCtxWhenFinished: config.stopTracksAndCloseCtxWhenFinished !== undefined ? config.stopTracksAndCloseCtxWhenFinished : true,\n      usingMediaRecorder: config.usingMediaRecorder !== undefined ? config.usingMediaRecorder : typeof window.MediaRecorder !== 'undefined',\n      enableEchoCancellation: config.enableEchoCancellation !== undefined ? config.enableEchoCancellation : true,\n      sampleRate: config.sampleRate !== undefined ? config.sampleRate : 44100,\n      onRecording: config.onRecording,\n      onAudioPress: config.onAudioPress\n    };\n\n    if (config.onRecording) {\n      this.recordingFn = evt => config.onRecording(evt);\n\n      this.em.addEventListener('recording', this.recordingFn);\n    }\n\n    if (config.onAudioProcesss) {\n      this.onAudioProcessFn = evt => config.onAudioProcesss(evt);\n\n      this.em.addEventListener('onaudioprocess', this.onAudioProcessFn);\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/arcsec/virufy-demo.github.io/src/helper/audio/RecorderService.js"],"names":["EncoderWav","EncoderMp3","EncoderFlac","RecorderService","constructor","config","cleanup","onRecording","em","removeEventListener","recordingFn","onAudioProcesss","onAudioProcessFn","createWorker","fn","js","toString","replace","blob","Blob","Worker","URL","createObjectURL","startRecording","timeslice","state","navigator","mediaDevices","getUserMedia","audioCtx","AudioContext","sampleRate","micGainNode","createGain","outputGainNode","createDynamicsCompressorNode","dynamicsCompressorNode","createDynamicsCompressor","createAnalyserNode","analyserNode","createAnalyser","forceScriptProcessor","broadcastAudioProcessEvents","usingMediaRecorder","processorNode","createScriptProcessor","processorBufferSize","createMediaStreamDestination","destinationNode","destination","manualEncoderId","encoderWorker","baseUrl","process","env","PUBLIC_URL","postMessage","encoderMimeType","addEventListener","e","event","Event","data","type","_onDataAvailable","userMediaConstraints","audio","echoCancellation","enableEchoCancellation","deviceId","then","stream","_startRecordingWithStream","catch","error","console","log","setMicGain","newGain","micGain","gain","setValueAtTime","currentTime","micAudioStream","inputStreamNode","createMediaStreamSource","context","onGraphSetupWithInputStream","connect","nextNode","onaudioprocess","_onAudioProcess","mediaRecorder","MediaRecorder","mimeType","evt","_onError","start","slicing","setInterval","anon","dispatchEvent","CustomEvent","detail","inputBuffer","outputBuffer","getChannelData","stopRecording","stop","clearInterval","chunks","push","chunkType","blobUrl","recording","ts","Date","getTime","size","disconnect","stopTracksAndCloseCtxWhenFinished","getTracks","forEach","track","close","window","webkitAudioContext","document","createDocumentFragment","undefined","onAudioPress"],"mappings":"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","sourcesContent":["/* eslint-disable max-len */\n/* eslint-disable consistent-return */\n/* eslint-disable no-underscore-dangle */\n// Vendor Library https://github.com/mogwai/pwa-audio-recorder/tree/master\n\nimport EncoderWav from './encoder-wav-worker';\nimport EncoderMp3 from './encoder-mp3-worker';\nimport EncoderFlac from './encoder-flac-worker';\n// import EncoderOgg from './encoder-ogg-worker';\n\nexport default class RecorderService {\n  constructor(config) {\n    window.AudioContext = window.AudioContext || window.webkitAudioContext;\n\n    this.em = document.createDocumentFragment();\n\n    this.state = 'inactive';\n\n    this.chunks = [];\n    this.chunkType = '';\n\n    this.encoderMimeType = 'audio/wav';\n\n    this.config = {\n      broadcastAudioProcessEvents: config.broadcastAudioProcessEvents !== undefined ? config.broadcastAudioProcessEvents : false,\n      createAnalyserNode: config.createAnalyserNode !== undefined ? config.createAnalyserNode : false,\n      createDynamicsCompressorNode: config.createDynamicsCompressorNode !== undefined ? config.createDynamicsCompressorNode : false,\n      forceScriptProcessor: config.forceScriptProcessor !== undefined ? config.forceScriptProcessor : false,\n      manualEncoderId: config.manualEncoderId !== undefined ? config.manualEncoderId : 'wav',\n      micGain: config.micGain !== undefined ? config.micGain : 1.0,\n      processorBufferSize: config.processorBufferSize !== undefined ? config.processorBufferSize : 2048,\n      stopTracksAndCloseCtxWhenFinished: config.stopTracksAndCloseCtxWhenFinished !== undefined ? config.stopTracksAndCloseCtxWhenFinished : true,\n      usingMediaRecorder: config.usingMediaRecorder !== undefined ? config.usingMediaRecorder : typeof window.MediaRecorder !== 'undefined',\n      enableEchoCancellation: config.enableEchoCancellation !== undefined ? config.enableEchoCancellation : true,\n      sampleRate: config.sampleRate !== undefined ? config.sampleRate : 44100,\n      onRecording: config.onRecording,\n      onAudioPress: config.onAudioPress,\n    };\n\n    if (config.onRecording) {\n      this.recordingFn = evt => config.onRecording(evt);\n      this.em.addEventListener('recording', this.recordingFn);\n    }\n    if (config.onAudioProcesss) {\n      this.onAudioProcessFn = evt => config.onAudioProcesss(evt);\n      this.em.addEventListener('onaudioprocess', this.onAudioProcessFn);\n    }\n  }\n\n  cleanup = () => {\n    if (this.config.onRecording) {\n      this.em.removeEventListener('recording', this.recordingFn);\n    }\n    if (this.config.onAudioProcesss) {\n      this.em.removeEventListener('onaudioprocess', this.onAudioProcessFn);\n    }\n  };\n\n  createWorker = fn => {\n    const js = fn\n      .toString()\n      .replace(/^function\\s*\\(\\)\\s*{/, '')\n      .replace(/}$/, '');\n    const blob = new Blob([js]);\n    return new Worker(URL.createObjectURL(blob));\n  };\n\n  startRecording = timeslice => {\n    if (this.state !== 'inactive') {\n      return;\n    }\n\n    // This is the case on ios/chrome, when clicking links from within ios/slack (sometimes), etc.\n    if (\n      !navigator\n      || !navigator.mediaDevices\n      || !navigator.mediaDevices.getUserMedia\n    ) {\n      // alert('Missing support for navigator.mediaDevices.getUserMedia'); // temp: helps when testing for strange issues on ios/safari\n      return;\n    }\n\n    this.audioCtx = new AudioContext({\n      sampleRate: this.config.sampleRate,\n    });\n    this.micGainNode = this.audioCtx.createGain();\n    this.outputGainNode = this.audioCtx.createGain();\n\n    if (this.config.createDynamicsCompressorNode) {\n      this.dynamicsCompressorNode = this.audioCtx.createDynamicsCompressor();\n    }\n\n    if (this.config.createAnalyserNode) {\n      this.analyserNode = this.audioCtx.createAnalyser();\n    }\n\n    // If not using MediaRecorder(i.e. safari and edge), then a script processor is required. It's optional\n    // on browsers using MediaRecorder and is only useful if wanting to do custom analysis or manipulation of\n    // recorded audio data.\n    if (\n      this.config.forceScriptProcessor\n      || this.config.broadcastAudioProcessEvents\n      || !this.config.usingMediaRecorder\n    ) {\n      this.processorNode = this.audioCtx.createScriptProcessor(\n        this.config.processorBufferSize,\n        1,\n        1,\n      ); // TODO: Get the number of channels from mic\n    }\n\n    // Create stream destination on chrome/firefox because, AFAICT, we have no other way of feeding audio graph output\n    // in to MediaRecorderSafari/Edge don't have this method as of 2018-04.\n    if (this.audioCtx.createMediaStreamDestination) {\n      this.destinationNode = this.audioCtx.createMediaStreamDestination();\n    } else {\n      this.destinationNode = this.audioCtx.destination;\n    }\n\n    // Create web worker for doing the encoding\n    if (!this.config.usingMediaRecorder) {\n      if (this.config.manualEncoderId === 'mp3') {\n        this.encoderWorker = this.createWorker(EncoderMp3);\n        const baseUrl = process.env.PUBLIC_URL || 'https://virufy.org/demo';\n        this.encoderWorker.postMessage([\n          'init',\n          { baseUrl, sampleRate: this.audioCtx.sampleRate },\n        ]);\n        this.encoderMimeType = 'audio/mpeg';\n      } else if (this.config.manualEncoderId === 'flac') {\n        this.encoderWorker = this.createWorker(EncoderFlac);\n        this.encoderWorker.postMessage([\n          'init',\n          { sampleRate: this.audioCtx.sampleRate },\n        ]);\n        this.encoderMimeType = 'audio/flac';\n      } else {\n        this.encoderWorker = this.createWorker(EncoderWav);\n        this.encoderMimeType = 'audio/wav';\n      }\n      this.encoderWorker.addEventListener('message', e => {\n        const event = new Event('dataavailable');\n        if (this.config.manualEncoderId === 'ogg' || this.config.manualEncoderId === 'flac') {\n          event.data = e.data;\n        } else {\n          event.data = new Blob(e.data, { type: this.encoderMimeType });\n        }\n        this._onDataAvailable(event);\n      });\n    }\n\n    // Setup media constraints\n    const userMediaConstraints = {\n      audio: {\n        echoCancellation: this.config.enableEchoCancellation,\n      },\n    };\n    if (this.config.deviceId) {\n      userMediaConstraints.audio.deviceId = this.config.deviceId;\n    }\n\n    // This will prompt user for permission if needed\n    return navigator.mediaDevices\n      .getUserMedia(userMediaConstraints)\n      .then(stream => {\n        this._startRecordingWithStream(stream, timeslice);\n      })\n      .catch(error => {\n        // alert(`Error with getUserMedia: ${error.message}`); // temp: helps when testing for strange issues on ios/safari\n        console.log(error);\n      });\n  };\n\n  setMicGain = newGain => {\n    this.config.micGain = newGain;\n    if (this.audioCtx && this.micGainNode) {\n      this.micGainNode.gain.setValueAtTime(newGain, this.audioCtx.currentTime);\n    }\n  };\n\n  _startRecordingWithStream = (stream, timeslice) => {\n    this.micAudioStream = stream;\n\n    this.inputStreamNode = this.audioCtx.createMediaStreamSource(\n      this.micAudioStream,\n    );\n    this.audioCtx = this.inputStreamNode.context;\n\n    // Kind-of a hack to allow hooking in to audioGraph inputStreamNode\n    if (this.onGraphSetupWithInputStream) {\n      this.onGraphSetupWithInputStream(this.inputStreamNode);\n    }\n\n    this.inputStreamNode.connect(this.micGainNode);\n    this.micGainNode.gain.setValueAtTime(\n      this.config.micGain,\n      this.audioCtx.currentTime,\n    );\n\n    let nextNode = this.micGainNode;\n    if (this.dynamicsCompressorNode) {\n      this.micGainNode.connect(this.dynamicsCompressorNode);\n      nextNode = this.dynamicsCompressorNode;\n    }\n\n    this.state = 'recording';\n\n    if (this.processorNode) {\n      nextNode.connect(this.processorNode);\n      this.processorNode.connect(this.outputGainNode);\n      this.processorNode.onaudioprocess = e => this._onAudioProcess(e);\n    } else {\n      nextNode.connect(this.outputGainNode);\n    }\n\n    if (this.analyserNode) {\n      // TODO: If we want the analyser node to receive the processorNode's output, this needs to be changed _and_\n      //       processor node needs to be modified to copy input to output. It currently doesn't because it's not\n      //       needed when doing manual encoding.\n      // this.processorNode.connect(this.analyserNode)\n      nextNode.connect(this.analyserNode);\n    }\n\n    this.outputGainNode.connect(this.destinationNode);\n\n    if (this.config.usingMediaRecorder) {\n      this.mediaRecorder = new MediaRecorder(this.destinationNode.stream, { mimeType: this.encoderMimeType || 'audio/wav' });\n      this.mediaRecorder.addEventListener('dataavailable', evt => this._onDataAvailable(evt));\n      this.mediaRecorder.addEventListener('error', evt => this._onError(evt));\n\n      this.mediaRecorder.start(timeslice);\n    } else {\n      // Output gain to zero to prevent feedback. Seems to matter only on Edge, though seems like should matter\n      // on iOS too.  Matters on chrome when connecting graph to directly to audioCtx.destination, but we are\n      // not able to do that when using MediaRecorder.\n      this.outputGainNode.gain.setValueAtTime(0, this.audioCtx.currentTime);\n      // this.outputGainNode.gain.value = 0\n\n      // Todo: Note that time slicing with manual wav encoderWav won't work. To allow it would require rewriting the encoderWav\n      // to assemble all chunks at end instead of adding header to each chunk.\n      if (timeslice) {\n        console.log(\n          'Time slicing without MediaRecorder is not yet supported. The resulting recording will not be playable.',\n        );\n        this.slicing = setInterval(function anon() {\n          if (this.state === 'recording') {\n            this.encoderWorker.postMessage(['dump', this.context.sampleRate]);\n          }\n        }, timeslice);\n      }\n    }\n  };\n\n  _onAudioProcess = e => {\n    // console.log('onaudioprocess', e)\n    // let inputBuffer = e.inputBuffer\n    // let outputBuffer = e.outputBuffer\n    // console.log(this.micAudioStream)\n    // console.log(this.audioCtx)\n    // console.log(this.micAudioStream.getTracks().forEach((track) => console.log(track)))\n\n    // this.onAudioEm.dispatch(new Event('onaudioprocess', {inputBuffer:inputBuffer,outputBuffer:outputBuffer}))\n\n    if (this.config.broadcastAudioProcessEvents) {\n      this.em.dispatchEvent(\n        new CustomEvent('onaudioprocess', {\n          detail: {\n            inputBuffer: e.inputBuffer,\n            outputBuffer: e.outputBuffer,\n          },\n        }),\n      );\n    }\n\n    // // Example handling:\n    // let inputBuffer = e.inputBuffer\n    // let outputBuffer = e.outputBuffer\n    // // Each channel (usually only one)\n    // for (let channel = 0; channel < outputBuffer.numberOfChannels; channel++) {\n    //   let inputData = inputBuffer.getChannelData(channel)\n    //   let outputData = outputBuffer.getChannelData(channel)\n    //\n    //   // Each sample\n    //   for (let sample = 0; sample < inputBuffer.length; sample++) {\n    //     // Make output equal to the same as the input (thus processor is doing nothing at this time)\n    //     outputData[sample] = inputData[sample]\n    //   }\n    // }\n\n    // When manually encoding (safari/edge), there's no reason to copy data to output buffer.  We set the output\n    // gain to 0 anyways (which is required on Edge if we did copy data to output). However, if using a MediaRecorder\n    // and a processor (all other browsers), then it would be required to copy the data otherwise the graph would\n    // generate no data for the MediaRecorder to consume.\n    // if (this.forceScriptProcessor) {\n\n    // // Copy input to output\n    // let inputBuffer = e.inputBuffer\n    // let outputBuffer = e.outputBuffer\n    // // This doesn't work on iOS/Safari. Guessing it doesn't have copyToChannel support, but haven't verified.\n    // for (let channel = 0; channel < outputBuffer.numberOfChannels; channel++) {\n    //   outputBuffer.copyToChannel(inputBuffer.getChannelData(channel), channel)\n    // }\n\n    // Safari and Edge require manual encoding via web worker. Single channel only for now.\n    // Example stereo encoderWav: https://github.com/MicrosoftEdge/Demos/blob/master/microphone/scripts/recorderworker.js\n    if (!this.config.usingMediaRecorder) {\n      if (this.state === 'recording') {\n        if (this.config.broadcastAudioProcessEvents) {\n          this.encoderWorker.postMessage([\n            'encode',\n            e.outputBuffer.getChannelData(0),\n          ]);\n        } else {\n          this.encoderWorker.postMessage([\n            'encode',\n            e.inputBuffer.getChannelData(0),\n          ]);\n        }\n      }\n    }\n  };\n\n  stopRecording = () => {\n    if (this.state === 'inactive') {\n      return;\n    }\n    if (this.config.usingMediaRecorder) {\n      this.state = 'inactive';\n      this.mediaRecorder.stop();\n    } else {\n      this.state = 'inactive';\n      this.encoderWorker.postMessage(['dump', this.audioCtx.sampleRate]);\n      clearInterval(this.slicing);\n\n      // TODO: There should be a more robust way to handle this\n      // Without something like this, I think  the last recorded sample could be lost due to timing\n      // setTimeout(() => {\n      //   this.state = 'inactive'\n      //   this.encoderWorker.postMessage(['dump', this.audioCtx.sampleRate])\n      // }, 100)\n    }\n  };\n\n  _onDataAvailable = evt => {\n    // console.log('state', this.mediaRecorder.state)\n    // console.log('evt.data', evt.data)\n\n    this.chunks.push(evt.data);\n    this.chunkType = evt.data.type;\n\n    if (this.state !== 'inactive') {\n      return;\n    }\n\n    const blob = new Blob(this.chunks, { type: this.chunkType });\n    const blobUrl = URL.createObjectURL(blob);\n    const recording = {\n      ts: new Date().getTime(),\n      blobUrl,\n      mimeType: blob.type,\n      size: blob.size,\n    };\n\n    this.chunks = [];\n    this.chunkType = null;\n\n    if (this.destinationNode) {\n      this.destinationNode.disconnect();\n      this.destinationNode = null;\n    }\n    if (this.outputGainNode) {\n      this.outputGainNode.disconnect();\n      this.outputGainNode = null;\n    }\n    if (this.analyserNode) {\n      this.analyserNode.disconnect();\n      this.analyserNode = null;\n    }\n    if (this.processorNode) {\n      this.processorNode.disconnect();\n      this.processorNode = null;\n    }\n    if (this.encoderWorker) {\n      this.encoderWorker.postMessage(['close']);\n      this.encoderWorker = null;\n    }\n    if (this.dynamicsCompressorNode) {\n      this.dynamicsCompressorNode.disconnect();\n      this.dynamicsCompressorNode = null;\n    }\n    if (this.micGainNode) {\n      this.micGainNode.disconnect();\n      this.micGainNode = null;\n    }\n    if (this.inputStreamNode) {\n      this.inputStreamNode.disconnect();\n      this.inputStreamNode = null;\n    }\n\n    if (this.config.stopTracksAndCloseCtxWhenFinished) {\n      // This removes the red bar in iOS/Safari\n      this.micAudioStream.getTracks().forEach(track => track.stop());\n      this.micAudioStream = null;\n\n      this.audioCtx.close();\n      this.audioCtx = null;\n    }\n\n    this.em.dispatchEvent(\n      new CustomEvent('recording', { detail: { recording } }),\n    );\n  };\n\n  _onError = evt => {\n    console.log('error', evt);\n    this.em.dispatchEvent(new Event('error'));\n    // alert(`error:${evt}`); // for debugging purposes\n  };\n}\n"]},"metadata":{},"sourceType":"module"}