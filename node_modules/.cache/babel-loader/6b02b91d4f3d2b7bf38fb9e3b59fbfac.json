{"ast":null,"code":"/* eslint-disable */\n\n/* eslint-disable func-names */\n\n/* global Flac */\nexport default function () {\n  const workersHost = process.env.PUBLIC_URL || process.env.REACT_APP_WORKERS_HOST || 'https://virufy.org/demo';\n  importScripts(`${workersHost}/workers/encoders/libflac.dev.js`); // eslint-disable-line\n\n  let flacEncoder;\n  let CHANNELS = 1;\n  let SAMPLERATE = 44100;\n  let COMPRESSION = 5;\n  let BPS = 16;\n  let flacOk = 1;\n  let flacLength = 0;\n  const flacBuffers = [];\n  let INIT = false;\n  const wavBuffers = []; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  function writeCallbackFn(buffer, bytes) {\n    flacBuffers.push(buffer);\n    flacLength += buffer.byteLength;\n  } // HELPER: handle initialization of flac encoder\n\n\n  function initFlac() {\n    flacEncoder = Flac.init_libflac_encoder(SAMPLERATE, CHANNELS, BPS, COMPRESSION, 0); /// /\n\n    if (flacEncoder !== 0) {\n      const statusEncoder = Flac.init_encoder_stream(flacEncoder, writeCallbackFn);\n      flacOk &= statusEncoder == 0;\n      console.log(`flac init     : ${flacOk}`); // DEBUG\n\n      console.log(`status encoder: ${statusEncoder}`); // DEBUG\n\n      INIT = true;\n    } else {\n      console.error('Error initializing the encoder.');\n    }\n  }\n\n  function init(config) {\n    let finalConfig = config;\n\n    if (!finalConfig) {\n      finalConfig = {\n        bps: BPS,\n        channels: CHANNELS,\n        samplerate: SAMPLERATE,\n        compression: COMPRESSION\n      };\n    }\n\n    finalConfig.channels = finalConfig.channels ? finalConfig.channels : CHANNELS;\n    finalConfig.samplerate = finalConfig.samplerate ? finalConfig.samplerate : SAMPLERATE;\n    finalConfig.bps = finalConfig.bps ? finalConfig.bps : BPS;\n    finalConfig.compression = finalConfig.compression ? finalConfig.compression : COMPRESSION; /// /\n\n    COMPRESSION = finalConfig.compression;\n    BPS = finalConfig.bps;\n    SAMPLERATE = finalConfig.samplerate;\n    CHANNELS = finalConfig.channels; /// /\n\n    if (!Flac.isReady()) {\n      Flac.onready = function () {\n        setTimeout(() => {\n          initFlac();\n        }, 0);\n      };\n    } else {\n      initFlac();\n    }\n  } // HELPER: actually encode PCM data to Flac\n\n\n  function doEncodeFlac(audioData) {\n    const bufLength = audioData.length;\n    const bufferI32 = new Uint32Array(bufLength);\n    const view = new DataView(bufferI32.buffer);\n    const volume = 1;\n    let index = 0;\n\n    for (let i = 0; i < bufLength; i += 1) {\n      view.setInt32(index, audioData[i] * (0x7FFF * volume), true);\n      index += 4;\n    }\n\n    const flacReturn = Flac.FLAC__stream_encoder_process_interleaved(flacEncoder, bufferI32, bufferI32.length / CHANNELS);\n\n    if (flacReturn != true) {\n      console.log(`Error: encode_buffer_pcm_as_flac returned false. ${flacReturn}`);\n    }\n  } // HELPER: handle incoming PCM audio data for Flac encoding:\n\n\n  function encodeFlac(audioData) {\n    if (!Flac.isReady()) {\n      // if Flac is not ready yet: buffer the audio\n      wavBuffers.push(audioData);\n      console.info('buffered audio data for Flac encdoing');\n    } else {\n      if (wavBuffers.length > 0) {\n        // if there is buffered audio: encode buffered first (and clear buffer)\n        const len = wavBuffers.length;\n        const buffered = wavBuffers.splice(0, len); // eslint-disable-next-line no-plusplus\n\n        for (let i = 0; i < len; ++i) {\n          doEncodeFlac(buffered[i]);\n        }\n      }\n\n      doEncodeFlac(audioData);\n    }\n  }\n\n  function mergeBuffersUint8(channelBuffer, recordingLength) {\n    const result = new Uint8Array(recordingLength);\n    let offset = 0;\n    const lng = channelBuffer.length;\n\n    for (let i = 0; i < lng; i += 1) {\n      const buffer = channelBuffer[i];\n      result.set(buffer, offset);\n      offset += buffer.length;\n    }\n\n    return result;\n  }\n\n  function exportFlacFile(recBuffers, recLength) {\n    // convert buffers into one single buffer\n    const samples = mergeBuffersUint8(recBuffers, recLength); // var audioBlob = new Blob([samples], { type: type });\n\n    const theBlob = new Blob([samples], {\n      type: 'audio/flac'\n    });\n    return theBlob;\n  }\n  /*\n   * clear recording buffers\n   */\n\n\n  function clear() {\n    flacBuffers.splice(0, flacBuffers.length);\n    flacLength = 0;\n    wavBuffers.splice(0, wavBuffers.length);\n  }\n\n  this.onmessage = function onmessage(e) {\n    if (e.data[0] === 'init') {\n      init(e.data[1]);\n    } else if (e.data[0] === 'encode') {\n      encodeFlac(e.data[1]);\n    } else if (e.data[0] === 'dump') {\n      let data;\n\n      if (!Flac.isReady()) {\n        console.error('Flac was not initialized: could not encode data!');\n      } else {\n        flacOk &= Flac.FLAC__stream_encoder_finish(flacEncoder);\n        console.log(`flac finish: ${flacOk}`); // DEBUG\n\n        data = exportFlacFile(flacBuffers, flacLength);\n        Flac.FLAC__stream_encoder_delete(flacEncoder);\n      }\n\n      clear();\n      postMessage(data);\n      INIT = false;\n    }\n  };\n}","map":{"version":3,"sources":["/home/amil/virufy-demo.github.io/src/helper/audio/encoder-flac-worker.js"],"names":["workersHost","process","env","PUBLIC_URL","REACT_APP_WORKERS_HOST","importScripts","flacEncoder","CHANNELS","SAMPLERATE","COMPRESSION","BPS","flacOk","flacLength","flacBuffers","INIT","wavBuffers","writeCallbackFn","buffer","bytes","push","byteLength","initFlac","Flac","init_libflac_encoder","statusEncoder","init_encoder_stream","console","log","error","init","config","finalConfig","bps","channels","samplerate","compression","isReady","onready","setTimeout","doEncodeFlac","audioData","bufLength","length","bufferI32","Uint32Array","view","DataView","volume","index","i","setInt32","flacReturn","FLAC__stream_encoder_process_interleaved","encodeFlac","info","len","buffered","splice","mergeBuffersUint8","channelBuffer","recordingLength","result","Uint8Array","offset","lng","set","exportFlacFile","recBuffers","recLength","samples","theBlob","Blob","type","clear","onmessage","e","data","FLAC__stream_encoder_finish","FLAC__stream_encoder_delete","postMessage"],"mappings":"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","sourcesContent":["/* eslint-disable */\n/* eslint-disable func-names */\n/* global Flac */\n\nexport default function () {\n  const workersHost = process.env.PUBLIC_URL || process.env.REACT_APP_WORKERS_HOST || 'https://virufy.org/demo';\n  importScripts(`${workersHost}/workers/encoders/libflac.dev.js`); // eslint-disable-line\n\n  let flacEncoder;\n  let CHANNELS = 1;\n  let SAMPLERATE = 44100;\n  let COMPRESSION = 5;\n  let BPS = 16;\n  let flacOk = 1;\n  let flacLength = 0;\n  const flacBuffers = [];\n  let INIT = false;\n  const wavBuffers = [];\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  function writeCallbackFn(buffer, bytes) {\n    flacBuffers.push(buffer);\n    flacLength += buffer.byteLength;\n  }\n\n  // HELPER: handle initialization of flac encoder\n  function initFlac() {\n    flacEncoder = Flac.init_libflac_encoder(SAMPLERATE, CHANNELS, BPS, COMPRESSION, 0);\n    /// /\n    if (flacEncoder !== 0) {\n      const statusEncoder = Flac.init_encoder_stream(flacEncoder, writeCallbackFn);\n      flacOk &= (statusEncoder == 0);\n\n      console.log(`flac init     : ${flacOk}`);// DEBUG\n      console.log(`status encoder: ${statusEncoder}`);// DEBUG\n\n      INIT = true;\n    } else {\n      console.error('Error initializing the encoder.');\n    }\n  }\n\n  function init(config) {\n    let finalConfig = config;\n\n    if (!finalConfig) {\n      finalConfig = {\n        bps: BPS, channels: CHANNELS, samplerate: SAMPLERATE, compression: COMPRESSION,\n      };\n    }\n\n    finalConfig.channels = finalConfig.channels ? finalConfig.channels : CHANNELS;\n    finalConfig.samplerate = finalConfig.samplerate ? finalConfig.samplerate : SAMPLERATE;\n    finalConfig.bps = finalConfig.bps ? finalConfig.bps : BPS;\n    finalConfig.compression = finalConfig.compression ? finalConfig.compression : COMPRESSION;\n\n    /// /\n    COMPRESSION = finalConfig.compression;\n    BPS = finalConfig.bps;\n    SAMPLERATE = finalConfig.samplerate;\n    CHANNELS = finalConfig.channels;\n    /// /\n\n    if (!Flac.isReady()) {\n      Flac.onready = function () {\n        setTimeout(() => {\n          initFlac();\n        }, 0);\n      };\n    } else {\n      initFlac();\n    }\n  }\n\n  // HELPER: actually encode PCM data to Flac\n  function doEncodeFlac(audioData) {\n    const bufLength = audioData.length;\n    const bufferI32 = new Uint32Array(bufLength);\n    const view = new DataView(bufferI32.buffer);\n    const volume = 1;\n    let index = 0;\n    for (let i = 0; i < bufLength; i += 1) {\n      view.setInt32(index, (audioData[i] * (0x7FFF * volume)), true);\n      index += 4;\n    }\n\n    const flacReturn = Flac.FLAC__stream_encoder_process_interleaved(\n      flacEncoder, bufferI32, bufferI32.length / CHANNELS,\n    );\n    if (flacReturn != true) {\n      console.log(`Error: encode_buffer_pcm_as_flac returned false. ${flacReturn}`);\n    }\n  }\n\n  // HELPER: handle incoming PCM audio data for Flac encoding:\n  function encodeFlac(audioData) {\n    if (!Flac.isReady()) {\n      // if Flac is not ready yet: buffer the audio\n      wavBuffers.push(audioData);\n      console.info('buffered audio data for Flac encdoing');\n    } else {\n      if (wavBuffers.length > 0) {\n        // if there is buffered audio: encode buffered first (and clear buffer)\n\n        const len = wavBuffers.length;\n        const buffered = wavBuffers.splice(0, len);\n        // eslint-disable-next-line no-plusplus\n        for (let i = 0; i < len; ++i) {\n          doEncodeFlac(buffered[i]);\n        }\n      }\n\n      doEncodeFlac(audioData);\n    }\n  }\n\n  function mergeBuffersUint8(channelBuffer, recordingLength) {\n    const result = new Uint8Array(recordingLength);\n    let offset = 0;\n    const lng = channelBuffer.length;\n    for (let i = 0; i < lng; i += 1) {\n      const buffer = channelBuffer[i];\n      result.set(buffer, offset);\n      offset += buffer.length;\n    }\n    return result;\n  }\n\n  function exportFlacFile(recBuffers, recLength) {\n    // convert buffers into one single buffer\n    const samples = mergeBuffersUint8(recBuffers, recLength);\n\n    // var audioBlob = new Blob([samples], { type: type });\n    const theBlob = new Blob([samples], { type: 'audio/flac' });\n    return theBlob;\n  }\n\n  /*\n   * clear recording buffers\n   */\n  function clear() {\n    flacBuffers.splice(0, flacBuffers.length);\n    flacLength = 0;\n    wavBuffers.splice(0, wavBuffers.length);\n  }\n\n  this.onmessage = function onmessage(e) {\n    if (e.data[0] === 'init') {\n      init(e.data[1]);\n    } else if (e.data[0] === 'encode') {\n      encodeFlac(e.data[1]);\n    } else if (e.data[0] === 'dump') {\n      let data;\n      if (!Flac.isReady()) {\n        console.error('Flac was not initialized: could not encode data!');\n      } else {\n        flacOk &= Flac.FLAC__stream_encoder_finish(flacEncoder);\n        console.log(`flac finish: ${flacOk}`);// DEBUG\n        data = exportFlacFile(flacBuffers, flacLength);\n\n        Flac.FLAC__stream_encoder_delete(flacEncoder);\n      }\n\n      clear();\n\n      postMessage(data);\n      INIT = false;\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}